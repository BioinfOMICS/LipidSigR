---
title: "LipidSigR tutorial"
author:
- name: Wei-Chung Cheng
  affiliation: China Medical University
output:
  BiocStyle::pdf_document:
    toc: TRUE
    number_sections: TRUE
    titlecaps: TRUE
    toc_newpage: TRUE
    latex_engine: pdflatex
  #BiocStyle::html_document:
    #toc_float: yes
bibliography: ref.bib
csl: nature.csl
abstract: |
  "LipidSigR" is an R package developed based on LipidSig web-based tool (http://www.chenglab.cmu.edu.tw/lipidsig/). This package integrates a comprehensive analysis for streamlined data mining of lipidomic datasets. We provide 4 main analysis workflows, which is "Profiling", "Differential expression", "Machine learning", and "Correlation". Each section provides unique aspects to analyze the lipidome profiling data based on different characteristics including lipid class, chain length, unsaturation, hydroxyl group, and fatty acid composition.
vignette: |
  %\VignetteIndexEntry{LipidSigR tutorial}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
always_allow_html: yes
---
<script src="https://raw.githubusercontent.com/datastorm-open/visNetwork/master/inst/htmlwidgets/visNetwork.js"></script>

`r R.version.string`

Bioconductor version `r BiocManager::version()`

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE)
knitr::opts_chunk$set(fig.width = 6, fig.height = 5)
knitr::opts_chunk$set(fig.align ="center")
```

```{r, include=FALSE}
options(tinytex.verbose = TRUE)
```

```{r style, echo = FALSE, results = 'asis'} 
BiocStyle::latex()
```

# Introduction {.unnumbered}
Lipidomics technology provides a fast and high-throughput screening to identify thousands of lipid species in cells, tissues, or other biological samples and has been broadly used in several areas of studies. 

**"LipidSigR"** is an R package developed based on LipidSig web-based tool [http://www.chenglab.cmu.edu.tw/lipidsig/](http://www.chenglab.cmu.edu.tw/lipidsig/) [@lipidsig]. This package integrates a comprehensive analysis for streamlined data mining of lipidomic datasets. We provide 4 main analysis workflows, which is **"Profiling"**, **"Differential expression"**, **"Machine learning"**, and **"Correlation"**. Each section provides unique aspects to analyze the lipidome profiling data based on different characteristics including lipid class, chain length, unsaturation, hydroxyl group, and fatty acid composition.

The usage of the 4 sections is introduced briefly as below. 

* **Profiling**: The profiling section provides an overview of comprehensive analyses for you to efficiently examine data quality, the clustering of samples, the correlation between lipid species, and the composition of lipid characteristics.
* **Differential expression**: The differential expression section integrates many useful lipid-focused analyses for identifying significant lipid species or lipid characteristics.
* **Machine learning**: The machine learning section provides a broad variety of feature selection methods and classifiers to build binary classification models. Furthermore, the subsequent analyses can help users to evaluate the learning algorithm's performance and to explore important lipid-related variables. 
* **Correlation**: The correlation section illustrates and compares the relationships between different clinical phenotypes and lipid features. 

The functions and usage of the above 4 sections are orderly described in the following sections, which is Profiling in Section \@ref(Profiling), Differential expression in Section \@ref(DE), Machine learning in Section \@ref(ML), and Correlation in Section \@ref(corr).

# Installation {.unnumbered}
Here is the procedures of running the **LipidSigR** package on your system. We assume that you have already installed the R program (see the R project at [http://www.r-project.org](http://www.r-project.org)  and are familiar with it. You need to have R 4.0.0 or a later version installed for running LipidSigR.

Our package is available at the Bioconductor repository [http://www.bioconductor.org](http://www.bioconductor.org). To install our package, first, you need to install the core Bioconductor packages. If you have already installed the Bioconductor packages on your system, you can skip the following step below.

```{r install_Bioconductor, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install()
```

Once the core Bioconductor packages have been installed, we can begin the installation of the LipidSigR package.

```{r install_package, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("LipidSigR")
``` 

After conducting the above step, now you can load in our package and start using it!

```{r load_package, message = FALSE}
library(LipidSigR)
```
```{r , message = FALSE, echo=FALSE}
library(plotly)
library(pathview)
library(SHAPforxgboost)
library(visNetwork)
```

# Profiling {#Profiling}
On the first step of analyzing lipid data, we have to take an overview of the data. In this section, you can get comprehensive analyses to explore the quality and the clustering of samples, the correlation between lipids and samples, and the expression and composition of lipids.

## Input data
First, we have to read the input data needed for the profiling section. We have to prepare lipid expression data and lipid characteristics (optional) as the input data of `exp_data` and `lipid_char_table`. Please note that `lipid_char_table` only be used in \@ref(subsec:pro_char).
```{r load_profiling_data}
# clears all objects from workspace
rm(list = ls())

# lipid expression data 
data("profiling_exp_data")
exp_data <- profiling_exp_data
head(exp_data[, 1:5], 5)

# lipid characteristics table (only use in Section 3.5)
data("profiling_lipid_char_table")
lipid_char_table <- profiling_lipid_char_table
head(lipid_char_table[, 1:4], 5)
```
After importing the input data, sometimes, we may need to conduct data processing before analysis. Here, we provide the `data_process` function for data processing, including removing features with missing values, missing values imputation, percentage transformation, log10 transformation, etc. 
```{r data_process}
# lipid expression data 
head(exp_data[, 1:5], 5)
# data processing of exp_data
exp_transform_table <- data_process(exp_data, exclude_var_missing=TRUE,
                                    missing_pct_limit=50, 
                                    replace_zero=TRUE, zero2what='min', 
                                    xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# exp_data after data processing
head(exp_transform_table[, 1:5], 5)
```

## Cross-sample variability
Now, let's start with a simple view of sample variability to compare the amount/expression difference of lipid between samples (i.e., patients vs. control).
```{r Profiling: cross-sample variability}
# conduct profiling
profiling_result <- exp_profiling(exp_data)
```
After conduct the above code, you will get a list `profiling_result` with three types of distribution plots.
```{r , fig.cap = "Histogram of number of expressed lipids. The histogram overviews the total number of lipid species over samples. From the plot, we can discover the number of lipid species present in each sample."}
# view result: histograms (number of expressed lipids)
profiling_result$i.expr.lip
```

```{r , fig.cap = "Histogram of lipid amount. The histogram describes the variability of the total lipid amount between samples."}
# view result: histogram (total amount of lipid)
profiling_result$i.p.amount      
```

```{r , fig.cap = "Density plot of expression distribution. The density plot uncovers the distribution of lipid expression in each sample (line). All expression was log10 transformed. From this plot, we can have a deeper view of the distribution between samples."}
# view result: density plot of expression distribution
profiling_result$p.hist.value
```


## Dimensionality reduction {#DimensionReduce}
Dimensionality reduction is commonly used when dealing with large numbers of observations and/or large numbers of variables in lipids analysis. It transforms data from a high-dimensional space into a low-dimensional space so that it retains vital properties of the original data and is close to its intrinsic dimension.

Here we provide 3 dimensionality reduction methods and 4 clustering methods. As for the number of groups shown on the PCA, t-SNE, and UMAP plot, it can be defined by users (default: 2 groups). 

1. **Dimensionality reduction methods**: PCA, t-SNE, UMAP.
2. **Clustering methods**: K-means, partitioning around medoids (PAM), Hierarchical clustering, and DBSCAN

###  PCA {#PCA}
PCA (Principal component analysis) is an unsupervised linear dimensionality reduction and data visualization technique for high dimensional data, which tries to preserve the global structure of the data. Scaling (by default) indicates that the variables should be scaled to have unit variance before the analysis takes place, which removes the bias towards high variances. In general, scaling (standardization) is advisable for data transformation when the variables in the original dataset have been measured on a significantly different scale. As for the centering options (by default), we offer the option of mean-centering, subtracting the mean of each variable from the values, making the mean of each variable equal to zero. It can help users to avoid the interference of misleading information given by the overall mean.
```{r Profiling: dimensionality reduction - PCA}
# data processing of exp_data
exp_transform_table <- data_process(exp_data, exclude_var_missing=TRUE,
                                    missing_pct_limit=50, 
                                    replace_zero=TRUE, zero2what='min', 
                                    xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# conduct PCA
PCA_result <- PCA(exp_transform_table,
                  group_info = NULL, sig_feature = NULL,
                  scaling=TRUE, centering=TRUE, cluster_method='kmeans',
                  group_num=2, var1 = NULL, var2 = NULL,
                  insert_ref_group=NULL, ref_group=NULL,
                  n_PC=c(1,2), top_n_feature=10)

# view result: PCA prcomp
head(PCA_result[[1]], 1)
```

```{r , fig.cap = "PCA plot"}
# view result: PCA plot
PCA_result[[4]]
```
Accompanying with the PCA plot, we offer scree plot criterion, which is a common method for determining the number of PCs to be retained. The "elbow" of the graph indicates all components to the left of this point can explain most variability of the samples.
```{r, fig.cap = "Scree plot"}
# view result: scree plot of top 10 principle components
PCA_result[[5]] 
```
Next, the two data frames related to PCA show the contribution to each principal component in each sample and the contribution of each feature (lipid species).
```{r }
# view result: data frame of PCA rotated data
head(PCA_result[[2]][,1:5], 5)
# view result: data frame of PCA contribution table
head(PCA_result[[3]][,1:5], 5)
```
Following is the correlation circle plot that reveals the relationships between all variables.
```{r, fig.cap = "Correlation circle plot. The correlation circle plot showing the correlation between a feature (lipid species) and a principal component (PC) used as the coordinates of the variable on the PC [@abdi2010principal]. The positively correlated variables are in the same quadrants while negatively correlated variables are on the opposite sides of the plot origin. The closer a variable to the edge of the circle, the better it represents on the factor map."}
# view result: correlation circle plot of PCA variables
PCA_result[[7]]
```

Lastly, we can have a closer look at the contribution of top 10 features to a user-defined principal component (e.g., PC1, PC2, or PC1+PC2). Therefore, in the histogram, we can find out the features (lipid species) that contribute more to the user-defined principal component.
```{r, fig.cap = "Bar plot of contribution of top 10 features"}
# view result: bar plot of contribution of top 10 features
PCA_result[[6]]  
```

### t-SNE  {#t-SNE}
t-SNE (t-Distributed Stochastic Neighbour Embedding) is an unsupervised non-linear dimensionality reduction technique that tries to retain the local structure(cluster) of data when visualising the high-dimensional datasets. Package `r CRANpkg("Rtsne")` is used for calculation, and PCA is applied as a pre-processing step. In t-SNE, `perplexity` and `max_iter` are adjustable for users. The `perplexity` may be considered as a knob that sets the number of effective nearest neighbours, while `max_iter` is the maximum number of iterations to perform. The typical perplexity range between 5 and 50, but if the t-SNE plot shows a ‘ball’ with uniformly distributed points, you may need to lower your perplexity [@van2008visualizing].
```{r Profiling: dimensionality reduction - t-SNE}
# data processing of exp_data
exp_transform_table <- data_process(exp_data, exclude_var_missing=TRUE,
                                    missing_pct_limit=50, 
                                    replace_zero=TRUE, zero2what='min', 
                                    xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# conduct t-SNE
tsne_result <- tsne(exp_transform_table, group_info = NULL,
                    sig_feature = NULL, pca=TRUE, perplexity=5,
                    max_iter=500, cluster_method='kmeans',
                    group_num=2, var1 = 'euclidean', var2 = NULL,
                    insert_ref_group = NULL, ref_group = NULL)

# view result: data frame of t-SNE data
head(tsne_result[[1]], 5)
```

```{r , fig.cap = "t-SNE plot"}
# view result: t-SNE plot
tsne_result[[2]] 
```

###  UMAP  {#UMAP}
UMAP (Uniform Manifold Approximation and Projection) using a nonlinear dimensionality reduction method, Manifold learning, which effectively visualizing clusters or groups of data points and their relative proximities. Both tSNE and UMAP are intended to predominantly preserve the local structure that is to group neighbouring data points which certainly delivers a very informative visualization of heterogeneity in the data. The significant difference with t-SNE is scalability, which allows UMAP eliminating the need for applying pre-processing step (such as PCA). Besides, UMAP applies Graph Laplacian for its initialization as tSNE by default implements random initialization. Thus, some people suggest that the key problem of tSNE is the Kullback-Leibler (KL) divergence, which makes UMAP superior over t-SNE. Nevertheless, UMAP’s cluster may not good enough for multi-class pattern classification [@mcinnes2018umap].
    
The type of distance metric to find nearest neighbors the size of the local neighborhood (as for the number of neighboring sample points) are set by parameter `metric` and `n_neighbors`. Larger values lead to more global views of the manifold, while smaller values result in more local data being preserved. Generally,  values are set in the range of 2 to 100. (default: 15).

```{r Profiling: dimensionality reduction - UMAP}
# data processing of exp_data
exp_transform_table <- data_process(exp_data, trans_type='log',
                                    exclude_var_missing=TRUE,
                                    missing_pct_limit=50,
                                    replace_zero=TRUE, replace_NA=TRUE,
                                    zero2what='min', xmin=0.5,
                                    NA2what='min', ymin=0.5,
                                    pct_transform=TRUE, centering=FALSE,
                                    data_transform=TRUE, scaling=FALSE )
# conduct UMAP
UMAP_result <- UMAP(exp_transform_table, group_info=NULL,
                    sig_feature=NULL, n_neighbors=15,
                    scale=TRUE, metric='euclidean', group_num=2,
                    cluster_method='kmeans', var1=NULL, var2=NULL,
                    insert_ref_group=NULL, ref_group=NULL)

# view result: data frame of UMAP data
head(UMAP_result[[1]], 5)
```

```{r , fig.cap = "UMAP plot"}
# view result: UMAP plot
UMAP_result[[2]]   
```

## Correlation heatmap
The correlation heatmap illustrates the correlation between samples or lipid species and also depicts the patterns in each group. The correlation is calculated by the method defined by parameter `corr_method`, and the correlation coefficient is then clustered depending on method defined by parameter `distfun` and the distance defined by parameter `hclustfun`. Two heatmaps will be shown by lipid species and by samples. Please note that if the number of lipids or samples is over 50, the names of lipids/samples will not be shown on the heatmap.
```{r Profiling: correlation heatmap}
# data processing of exp_data
exp_transform <- data_process(exp_data, exclude_var_missing=TRUE,
                              missing_pct_limit=50, replace_zero=TRUE,
                              zero2what='min', xmin=0.5, replace_NA=TRUE,
                              NA2what='min', ymin=0.5, pct_transform=TRUE,
                              data_transform=TRUE, trans_type='log',
                              centering=FALSE, scaling=FALSE)
# correlation calculation
corr_result <- corr_heatmap(exp_transform, corr_method="pearson",
                            distfun="maximum", hclustfun="average")

# view result: matrix of correlation coefficients           
head(corr_result$sample_corr_coef[, 1:5], 5)

# view result: matrix of correlation p-value  
head(corr_result$sample_corr_p[, 1:4], 5)

# view result: matrix of reorder sample correlation
head(corr_result$reorder_sample_corr_coef[, 1:3], 5)

# view result: matrix of correlation coefficients between lipids
head(corr_result$lipids_corr_coef[, 1:5], 5)

# view result: matrix of correlation p-value between lipids
head(corr_result$lipid_corr_p[, 1:4], 5)
```

```{r , fig.cap = "Heatmap of sample to sample correlations."}
# view result: sample-sample heatmap
corr_result$sample_hm  
```
The above heatmap reveals sample to sample correlations. Correlations between lipid species are colored from strong positive correlations (red) to no correlation (white).
```{r , fig.cap = "Heatmap of lipid to lipid correlations."}
# view result: lipid-lipid correlations heatmap
corr_result$lipids_hm
```
The above heatmap illustrates the lipid to lipid correlations. Correlations between lipid species are colored from strong positive correlation (red) to no correlation (white), to negative correlation (blue).

## Lipid characteristics {#subsec:pro_char}
Now, we are going to take a view of lipid expression over specific lipid characteristics. First, lipids are classified by characteristics selected from the 'Lipid characteristics' table. Here, we select "class" as the selected lipid characteristic. The results will be showed by two plots.
```{r Profiling: lipid characteristics}
# lipid characteristic
char_var <- colnames(lipid_char_table)[-1]
# calculate lipid expression of selected characteristic
compo_result <- exp_compo_by_lipidinfo(exp_data, lipid_char_table, char_var[1])
```

```{r , fig.cap = "Bar plot classified by selected characteristic. The bar plot depicts the expression level of each sample within each group (e.g., PE, PC) of selected characteristics (e.g., class)."}
# view result: bar plot
compo_result$p.barplot.p  
```
 
```{r , fig.cap = "Lipid class composition. The stacked horizontal bar chart illustrates the percentage of characteristics in each sample. The variability of percentage between samples can also be obtained from this plot."}
# view result: stacked horizontal bar chart
compo_result$p.compos      
```


# Differential expression {#DE}
After overviewing the lipid data, then we move on to differential expression to identify the significant lipid species and lipid characteristics. Differential Expression is divided into two main analyses, **'Lipid species analysis'** and **'Lipid characteristics analysis'**. Further analysis and visualization methods can also be conducted based on the results of differential expressed analysis.

* **Lipid species analysis**: The lipid species analysis explores the significant lipid species based on differentially expressed analysis. Data are analyzed based on each lipid species. Further analysis and visualization methods, include 

  1. dimensionality reduction,
  2. hierarchical clustering,
  3. characteristics association,
  4. enrichment.

* **Lipid characteristics analysis**: The lipid characteristics analysis explores the significant lipid characteristics. Lipid species are categorized and summarized into a new lipid expression table according to a selected lipid characteristic.  The expression of all lipid species of the same categories are summed up, then conduct differential expressed analysis. Further analysis and visualization methods include

  1. dimensionality reduction, 
  2. hierarchical clustering.

## Input data
First, we have to read the input data needed for the differential expression section. We have to prepare lipid expression data (`exp_data`), lipid characteristics table (`lipid_char_table`), and a table of one clinical term (or one set of clinical terms) from demographic data (`group_info`) as input data.
```{r load_DE_data}
# clears all objects from workspace
rm(list = ls())

# lipid expression data
data("DE_exp_data")
exp_data <- DE_exp_data
head(exp_data[, 1:5], 5)

# lipid characteristics table
data("DE_lipid_char_table")
lipid_char_table <- DE_lipid_char_table
head(lipid_char_table[, 1:4], 5)

# group information table
data("DE_group_info")
group_info <- DE_group_info
head(group_info, 5)
```
After importing the input data, sometimes, we may need to conduct data processing before analysis. Here, we provide the `data_process` function for data processing, including removing features with missing values, missing values imputation, percentage transformation, log10 transformation, etc.
```{r DE_data_process}
# lipid expression data
head(exp_data[, 1:5], 5)
# data processing of exp_data
exp_transform_table <- data_process(exp_data, exclude_var_missing=TRUE,
                                    missing_pct_limit=50, 
                                    replace_zero=TRUE, zero2what='min', 
                                    xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
head(exp_transform_table[, 1:5], 5)
```

## Lipid species analysis
Now, let's start with the analysis of lipid species.

### Differentially expressed analysis
For lipid species analysis section, differentially expressed analysis is performed to figure out significant lipid species. In short, samples will be divided into two groups (independent) according to the input "Group Information" table.

```{r DE_lipid species: differentially expressed analysis}
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data, exclude_var_missing=TRUE,
                                      missing_pct_limit=50, replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE, trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# conduct differentially expressed analysis of lipid species
DE_species_result <- DE_species_2(exp_transform_non_log,
                                  data_transform=TRUE,
                                  group_info = group_info,
                                  paired=FALSE, test='t.test',
                                  adjust_p_method='BH', sig_stat='p.adj',
                                  sig_pvalue=0.05, sig_FC=2)

# view result: data frame of lipid species
head(DE_species_result$DE_species_table_all[, 1:5], 5)

# view result: data frame of significant lipid species
head(DE_species_result$DE_species_table_sig [, 1:5], 5)
```
The above `DE_species_table_sig` data frame will be used in the following analyses in Section \@ref(DEdimensionReduce), Section \@ref(hierarchicalCluster), Section \@ref(speciesChar), and Section \@ref(enrichment).
```{r , fig.cap = "Lollipop chart of lipid species analysis. The lollipop chart reveals the lipid species that pass chosen cut-offs. The x-axis shows log2 fold change while the y-axis is a list of lipids species. The color of the point is determined by `-log10(adj_value/p-value)`."}
# view result: lollipop chart
DE_species_result$DE_species_dotchart_sig   
```

```{r , fig.cap = "MA plot. The MA plot indicates three groups of lipid species, up-regulated(red), down-regulated(blue), and non-significant(grey)."}
# view result: MA plot
DE_species_result$DE_species_maplot 
```
 

```{r , fig.cap = "Volcano plot. The volcano plot illustrates a similar concept to the MA plot. These points visually identify the most biologically significant lipid species (red for up-regulated, blue for down-regulated, and grey for non-significant)."}
# view result: MA plot
DE_species_result$DE_species_volcano  
```

### Dimensionality reduction {#DEdimensionReduce}
Dimensionality reduction is common when dealing with large numbers of observations and/or large numbers of variables in lipids analysis. It transforms data from a high-dimensional space into a low-dimensional space to retain vital properties of the original data and close to its intrinsic dimension. 

Here, we provide 4 dimensionality reduction methods, namely, PCA, t-SNE, UMAP, and PLS-DA. For the detailed information of the former three methods, please refer to Section \@ref(DimensionReduce).

* Note: The input data of this section should be by filtered by function `DE_species_2`.

#### PCA (Principal component analysis)
PCA is an unsupervised linear dimensionality reduction and data visualization technique for high dimensional data, which tries to preserve the global structure of the data. For detailed information of PCA, please refer to Section \@ref(PCA).
```{r DE_lipid species: dimensionality reduction - PCA}
# data processing of exp_data
exp_transform_table <- data_process(exp_data, exclude_var_missing=TRUE,
                                    missing_pct_limit=50, 
                                    replace_zero=TRUE, zero2what='min', 
                                    xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data, exclude_var_missing=TRUE,
                                      missing_pct_limit=50, replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE, trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter significant lipid
DE_species_table_sig <- DE_species_2(exp_transform_non_log, 
                                     data_transform=TRUE,
                                     group_info = group_info, paired=FALSE,
                                     test='t.test', adjust_p_method='BH',
                                     sig_stat='p.adj', sig_pvalue=0.05,
                                     sig_FC=2)$DE_species_table_sig
# conduct PCA
DEspec_PCA <- PCA(exp_transform_table,
                  group_info = group_info,
                  sig_feature = DE_species_table_sig$feature,
                  scaling=TRUE, centering=TRUE, group_num=2,
                  cluster_method='kmeans', var1=NULL, var2=NULL,
                  insert_ref_group=NULL, ref_group=NULL,
                  n_PC=c(1,2), top_n_feature=10)

# view result: PCA prcomp
head(DEspec_PCA[[1]], 1)

# view result: data frame of PCA rotated data
head(DEspec_PCA[[2]][,1:4], 5)

# view result: data frame of PCA contribution table
head(DEspec_PCA[[3]][,1:3], 5)
```

```{r , fig.cap = "PCA Results - PCA plot"}
# view result: PCA plot
DEspec_PCA[[4]]  
```
```{r , fig.cap = "PCA Results - scree plot"}
# view result: scree plot
DEspec_PCA[[5]] 
```
```{r , fig.cap = "PCA Results - bar plot"}
# view result: bar plot of contribution of top 10 features
DEspec_PCA[[6]]  
```
```{r , fig.cap = "PCA Results - correlation circle plot"}
# view result: correlation circle plot of variables
DEspec_PCA[[7]]
```

#### t-SNE (t-distributed stochastic neighbour embedding)
t-Distributed Stochastic Neighbour Embedding (t-SNE) is an unsupervised non-linear dimensionality reduction technique that tries to retain the local structure(cluster) of data when visualising the high-dimensional datasets. For detailed information of t-SNE, please refer to Section \@ref(t-SNE).

```{r DE_lipid species: dimensionality reduction - t-SNE}
# data processing of exp_data
exp_transform_table <- data_process(exp_data, exclude_var_missing=TRUE,
                                    missing_pct_limit=50, 
                                    replace_zero=TRUE, xmin=0.5, 
                                    zero2what='min', replace_NA=TRUE,
                                    ymin=0.5, NA2what='min', 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data, exclude_var_missing=TRUE,
                                      missing_pct_limit=50, replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE, trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter significant lipid
DE_species_table_sig <- DE_species_2(exp_transform_non_log, 
                                     data_transform=TRUE,
                                     group_info = group_info, paired=FALSE,
                                     test='t.test', adjust_p_method='BH',
                                     sig_stat='p.adj', sig_pvalue=0.05,
                                     sig_FC=2)$DE_species_table_sig
# conduct t-SNE
DEspec_tsne <- tsne(exp_transform_table,
                    group_info = group_info,
                    sig_feature=DE_species_table_sig$feature,
                    pca=TRUE, perplexity=5, max_iter=500,
                    cluster_method='kmeans', group_num=2,
                    var1 = 'euclidean', var2 = NULL,
                    insert_ref_group=NULL, ref_group=NULL)

# view result: data frame of t-SNE data
head(DEspec_tsne[[1]], 5)
```

```{r , fig.cap = "t-SNE plot"}
# view result: t-SNE plot
DEspec_tsne[[2]]     
```

#### UMAP (Uniform Manifold Approximation and Projection)
UMAP using a nonlinear dimensionality reduction method, Manifold learning, which effectively visualizing clusters or groups of data points and their relative proximities. For detailed information of UMAP, please refer to Section \@ref(UMAP).

```{r DE_lipid species: dimensionality reduction - UMAP}
# data processing of exp_data
exp_transform_table <- data_process(exp_data, exclude_var_missing=TRUE,
                                    missing_pct_limit=50, 
                                    replace_zero=TRUE, xmin=0.5, 
                                    zero2what='min', replace_NA=TRUE,
                                    ymin=0.5, NA2what='min', 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data, exclude_var_missing=TRUE,
                                      missing_pct_limit=50, replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE, trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter significant lipid
DE_species_table_sig <- DE_species_2(exp_transform_non_log, 
                                     data_transform=TRUE,
                                     group_info = group_info, paired=FALSE,
                                     test='t.test', adjust_p_method='BH',
                                     sig_stat='p.adj', sig_pvalue=0.05,
                                     sig_FC=2)$DE_species_table_sig
# conduct UMAP
DEspec_UMAP <- UMAP(exp_transform_table, group_num=2,
                    group_info=group_info, n_neighbors=15,
                    sig_feature=DE_species_table_sig$feature,
                    metric='euclidean', scale=TRUE, var1=NULL,
                    cluster_method='kmeans', var2=NULL,
                    insert_ref_group=NULL, ref_group=NULL)

# view result: data frame of UMAP data
head(DEspec_UMAP[[1]], 5)
```

```{r , fig.cap = "UMAP plot"}
# view result: UMAP plot
DEspec_UMAP[[2]]     
```

#### PLS-DA
```{r DE_lipid species: dimensionality reduction - PLS-DA}
# data processing of exp_data
exp_transform_table <- data_process(exp_data, replace_zero=TRUE,
                                    exclude_var_missing=TRUE,
                                    missing_pct_limit=50,
                                    zero2what='min',
                                    xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5,
                                    pct_transform=TRUE, data_transform=TRUE,
                                    trans_type='log', centering=FALSE, 
                                    scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data, exclude_var_missing=TRUE,
                                      missing_pct_limit=50, replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE, trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter significant lipid
DE_species_table_sig <- DE_species_2(exp_transform_non_log, 
                                     data_transform=TRUE,
                                     group_info = group_info, paired=FALSE,
                                     test='t.test', adjust_p_method='BH',
                                     sig_stat='p.adj', sig_pvalue=0.05,
                                     sig_FC=2)$DE_species_table_sig
# conduct PLSDA
DEspec_PLSDA <- PLSDA(exp_transform_table, scaling=TRUE,
                      group_info=group_info, ncomp=2,
                      sig_feature=DE_species_table_sig$feature,
                      cluster_method='group_info',
                      group_num=NULL, var1=NULL, var2=NULL,
                      insert_ref_group=NULL, ref_group=NULL)

# view result: data frame of sample variate
head(DEspec_PLSDA[[1]], 5)

# view result: data frame of sample loading
head(DEspec_PLSDA[[2]], 5)
```

```{r , fig.cap = "Sample plot"}
# view result: PLS-DA sample plot
DEspec_PLSDA[[3]]  
```

```{r , fig.cap = "Loading plot. In the PLS-DA loading plot, the distance to the center of the variables indicates the contribution of the variable. The value of the x-axis reveals the contribution of the variable to PLS-DA-1, whereas the value of the y-axis discloses the contribution of the variable to PLS-DA-2."}
# view result: PLS-DA variable plot
DEspec_PLSDA[[4]]     
```


### Hierarchical clustering {#hierarchicalCluster}
Based on the results of differentially expressed analysis, we further take a look at differences of lipid species between the control group and the experimental group. Lipid species derived from two groups are clustered and visualized on heatmap by hierarchical clustering. 
    
The top of the heatmap is grouped by sample group (top annotation) while the side of the heatmap (row annotation) can be chosen from `lipid_char_table`, such as class, structural category, functional category, total length, total double bond (totaldb), hydroxyl group number (totaloh), fatty acid length (FA_length), the double bond of fatty acid(FA_db), hydroxyl group number of fatty acid(FA_oh).

```{r DE_lipid species: hierarchical clustering}
# data processing of exp_data
exp_transform <- data_process(exp_data, exclude_var_missing=TRUE,
                              missing_pct_limit=50, replace_zero=TRUE,
                              zero2what='min', xmin=0.5, replace_NA=TRUE,
                              NA2what='min', ymin=0.5, pct_transform=TRUE,
                              data_transform=TRUE, trans_type='log',
                              centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data,
                                      exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      replace_zero=TRUE, zero2what='min',
                                      xmin=0.5, replace_NA=TRUE,
                                      NA2what='min', ymin=0.5,
                                      pct_transform=TRUE,
                                      data_transform=FALSE,
                                      trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter lipid_char_table according to exp_transform
lipid_char_filter <- lipid_char_table %>%
  filter(feature %in% exp_transform$feature)
# filter significant lipid
DE_species_table_sig <- DE_species_2(exp_transform_non_log,
                                     data_transform=TRUE,
                                     group_info = group_info,
                                     paired=FALSE, test='t.test',
                                     adjust_p_method='BH',
                                     sig_stat='p.adj', sig_pvalue=0.05,
                                     sig_FC=2)$DE_species_table_sig
# get lipid characteristics
char_var <- colnames(lipid_char_filter)[-1]
# conduct hierarchical clustering
DEspec_Hcluster<- Hclustering(exp_transform, DE_species_table_sig,
                              group_info, lipid_char_filter,
                              char_var = char_var[1],
                              distfun='pearson', hclustfun='complete')

# view result: matrix of all lipid species heatmap
head(DEspec_Hcluster$all.lipid.data[, 1:4], 5)

# view result: matrix of significant lipid species heatmap
head(DEspec_Hcluster$sig.lipid.data[, 1:4], 5)
```

```{r , fig.cap = "Heatmap of all lipid species"}
# view result: heatmap of all lipid species
DEspec_Hcluster$all.lipid 
```

```{r , fig.cap = "Heatmap of significant lipid species"}
# view result: heatmap of significant lipid species
DEspec_Hcluster$sig.lipid  
```
Through heatmap, we can discover the difference between the two groups by observing the distribution of lipid species.


### Characteristics analysis {#speciesChar}
The characteristics analysis visualizes the difference between control and experimental groups of significant lipid species categorized based on different lipid characteristics from `lipid_char_table`, such as class, structural category, functional category, total length, total double bond (totaldb), hydroxyl group number (totaloh), fatty acid length (FA_length), the double bond of fatty acid (FA_db), hydroxyl group number of fatty acid (FA_oh).
```{r DE_lipid species: characteristics analysis}
# data processing of exp_data
exp_transform <- data_process(exp_data, exclude_var_missing=TRUE,
                              missing_pct_limit=50,
                              replace_zero=TRUE, zero2what='min',
                              xmin=0.5, replace_NA=TRUE,
                              NA2what='min', pct_transform=TRUE,
                              data_transform=TRUE, trans_type='log',
                              ymin=0.5, centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data, exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE,
                                      trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter lipid_char_table according to exp_transform
lipid_char_filter <- lipid_char_table %>%
  filter(feature %in% exp_transform_non_log$feature)
# filter significant lipid
DE_species_table_sig <- DE_species_2(exp_transform_non_log,
                                     data_transform=TRUE,
                                     group_info = group_info,
                                     paired=FALSE, test='t.test',
                                     adjust_p_method='BH',
                                     sig_stat='p.adj', sig_pvalue=0.05,
                                     sig_FC=2)$DE_species_table_sig
# get lipid characteristics
char_var <- colnames(lipid_char_filter)[-1]
# conduct Sig_lipid_feature
sig_feature_result <- Sig_lipid_feature(DE_species_table_sig,
                                        lipid_char_filter,
                                        char_var[1], sig_FC=2)
```

```{r , fig.cap = "The bar chart of significant groups. The bar chart shows the significant groups (values) with mean fold change over 2 in the selected characteristics by colors (red for significant and black for insignificant). "}
# view result: bar chart
sig_feature_result$barPlot  
```

```{r , fig.cap = "The lollipop chart of all significant groups. The lollipop chart compares multiple values simultaneously and it aligns the log2(fold change) of all significant groups (values) within the selected characteristics. "}
# view result: lollipop plot
sig_feature_result$lolipop 
```

```{r , fig.cap = "Word cloud with the count of each group. The word cloud shows the count of each group(value) of the selected characteristics.", fig.width=3, fig.height=3}
# view result: word cloud 
sig_feature_result$word   
```


### Enrichment {#enrichment}
Enrichment analysis assist us to determine whether significant lipid species are enriched in the categories of the selected characteristics.
```{r DE_lipid species: enrichment}
# data processing of exp_data
exp_transform <- data_process(exp_data, exclude_var_missing=TRUE,
                              missing_pct_limit=50, replace_zero=TRUE,
                              zero2what='min', xmin=0.5, replace_NA=TRUE,
                              NA2what='min', ymin=0.5, pct_transform=TRUE,
                              data_transform=TRUE, trans_type='log',
                              centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data,
                                      exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      replace_zero=TRUE, zero2what='min',
                                      xmin=0.5, replace_NA=TRUE,
                                      NA2what='min', ymin=0.5,
                                      pct_transform=TRUE, data_transform=FALSE,
                                      trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter lipid_char_table according to exp_transform
lipid_char_filter <- lipid_char_table %>%
  filter(feature %in% exp_transform$feature)
# filter significant lipid
DE_species_table_sig <- DE_species_2(exp_transform_non_log,
                                     data_transform = T,
                                     group_info = group_info,
                                     paired=FALSE, test='t.test',
                                     adjust_p_method='BH',
                                     sig_stat='p.adj', sig_pvalue=0.05,
                                     sig_FC=2)$DE_species_table_sig
# get lipid characteristics
char_var <- colnames(lipid_char_filter)[-1]
# conduct enrichment analysis
enrich_result <- Enrichment(DE_species_table_sig,
                            lipid_char_table = lipid_char_filter,
                            char_var=char_var[1], sig_pvalue=0.05)
```
* Note: A lipid species may have more than one fatty acid attached; thus, if the selected lipid characteristics are FA-related terms, we decompose lipid species into FA and do the enrichment instead of counting species.

```{r , fig.cap = "Enrichment plot for up/down/non-significant groups. The enrichment summary table and plot are classified into up/down/non-significant groups by log2 fold change of significant lipid species. Each group (value) of the selected characteristics will have a value of significant count and p-value within a summary table."}
# view result: summary data frame of enrichment
head(enrich_result$enrich_char_table[, 1:5], 5)

# view result: enrichment plot
enrich_result$enrich_char_barplot   
```


Then, only when we select ‘class’ aslipid characteristic, KEGG pathway analysis can be executed.The names of significant lipid classes in enrichment analysis will be matched to our mapping table and find corresponding KEGG compound ID and KEGG pathways.

Here, we provide data on lipid-related pathways and genes. For conducting pathway analysis, we will need the following two data, `DE.lipid.gene.path` and `DE.pathway.gene.list`. 

* `DE.lipid.gene.path`: A data frame of pathway information, which can be retrieved and reorganized from KEGG or other databases. It includes the related pathways of lipids, ID, pathway ID, pathway name, gene ID, and gene name.
* `DE.pathway.gene.list`: A list that comprises the genes included in each pathway for compiling the significant network of the selected lipid class.
```{r DE_lipid species: enrichment_pathview}
# data frame of pathway information
data("DE_lipid_gene_path")
DE.lipid.gene.path <- DE_lipid_gene_path
head(DE.lipid.gene.path[, 1:4], 5)

# list of genes included in each pathway
data("DE_pathway_gene_list")
DE.pathway.gene.list <- DE_pathway_gene_list
head(DE.pathway.gene.list, 2)

# data processing of exp_data
exp_transform <- data_process(exp_data, exclude_var_missing=TRUE,
                              missing_pct_limit=50, replace_zero=TRUE,
                              zero2what='min', xmin=0.5, replace_NA=TRUE,
                              ymin=0.5, NA2what='min', data_transform=TRUE,
                              pct_transform=TRUE, trans_type='log',
                              centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data, replace_zero=TRUE,
                                      exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, ymin=0.5,
                                      NA2what='min', centering=FALSE,
                                      pct_transform=TRUE, scaling=FALSE,
                                      data_transform=FALSE, trans_type='log')
# filter lipid_char_table according to exp_transform
lipid_char_filter <- lipid_char_table %>%
  filter(feature %in% exp_transform$feature)
# filter significant lipid
DE_species_table_sig <- DE_species_2(exp_transform_non_log,
                                     data_transform=TRUE,
                                     group_info = group_info,
                                     paired=FALSE, test = 't.test',
                                     adjust_p_method = 'BH',
                                     sig_stat = 'p.adj', sig_pvalue=0.05,
                                     sig_FC=2)$DE_species_table_sig
# get lipid characteristics
char_var <- colnames(lipid_char_filter)[-1]
# get enrich characteristic table
enrich_char_table <- Enrichment(DE_species_table_sig,
                                lipid_char_table=lipid_char_filter,
                                char_var = char_var[1],
                                sig_pvalue=0.05)$enrich_char_table
# filter "class" of significant characteristics
sig_enrich_class <- enrich_char_table %>% filter(significant == 'YES') %>%
  distinct(characteristic) %>% .$characteristic
# set output path
dir.create(file.path(getwd(),"pathview_result"), recursive=TRUE, 
           showWarnings=TRUE)
outPath <- file.path(getwd(), "pathview_result")
# conduct pathview analysis
path_result <- pathview_function(sig_enrich_class, path=outPath,
                                 DE.lipid.gene.path, DE.pathway.gene.list)
```

```{r }
# view result: data frame of pathway information
path_result
```

```{r , fig.cap = "An example of KEGG pathway", fig.width=8, fig.height=8}
# view result: pathview plot
showimage::show_image(file.path(outPath,"hsa00565.pathview.png"))
```


## Lipid characteristics analysis
After lipid species analysis, now let's move on to another main analysis of the Differential expression section -- **'Lipid Characteristics Analysis'**. The massive degree of structural diversity of lipids contributes to the functional variety of lipids. The characteristics can range from subtle variance (i.e. the number of a double bond in the fatty acid) to major change (i.e. diverse backbones). In this section, lipid species are categorized and summarized into a new lipid expression table according to two selected lipid characteristics, then conducted differential expressed analysis. Samples are divided into two groups based on the input 'Group Information' table.

### Differentially expressed analysis {#sec:DE-char}
In differentially expressed analysis, we are going to conduct two procedures of analysis - first is **'Characteristics'** and then **'Subgroup of characteristics'**. **'Characteristics'** is based on the first selected 'characteristics' while **'Subgroup of characteristics'** is the subgroup analysis of the previous section.

```{r DE_lipid characteristics: differentially expressed analysis}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# aggregated(sum) expression data by selected characteristics
exp_data_Spe2Char <- Species2Char(exp_data, lipid_char_table,
                                  char_var = char_var[4])
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data_Spe2Char,
                                      exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE,
                                      trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# conduct deferentially expressed of lipid characters
DE_char_result <- DE_char_2(exp_transform_non_log, data_transform=TRUE,
                            group_info = group_info, paired=FALSE,
                            sig_pvalue=0.05, sig_FC=2,
                            insert_ref_group=NULL, ref_group=NULL)

# view result: data frame of expression
head(DE_char_result$DE_char_exp_data[, 1:5], 5)

# view result: data frame of statistical analysis
head(DE_char_result$DE_char_table_all[, 1:5], 5)

# view result: data frame with value of the continuous lipid characteristics
head(DE_char_result$DE_char_combined_table[, 1:5])

# view result: data frame with statistics of t.test
head(DE_char_result$DE_char_combine_result_table[, 1:5])
```

```{r , fig.cap = "The results of 'Characteristics' analysis in the first section - bar plot", fig.width=7}
# view result: bar plot of split_class
DE_char_result$DE_char_barplot 
```
```{r , fig.cap = "The results of 'Characteristics' analysis in the first section - sqrt-scaled bar plot", fig.width=7}
# view result: sqrt-scaled bar plot of split_class
DE_char_result$DE_char_barplot_sqrt
```
```{r , fig.cap = "The results of 'Characteristics' analysis in the first section - line plot", fig.width=7}
# view result: line plot of split_class
DE_char_result$DE_char_trendplot  
```
```{r , fig.cap = "The results of 'Characteristics' analysis in the first section - sqrt-scaled line plot", fig.width=7}
# view result: sqrt-scaled line plot of split_class
DE_char_result$DE_char_trendplot_sqrt  
```
```{r , fig.cap = "The results of 'Characteristics' analysis in the first section - box plot", fig.width=7}
# view result: box plot of split_class
DE_char_result$DE_char_boxplot  
```
In the **'Subgroup of characteristics'**, besides the selected characteristic in first section defined by parameter `char_var`, we can further choose another characteristic by parameter `split_var` (e.g. class). And then, analyzed results from the previous section are categorized by one of the subgroups (e.g. PC) of the selected characteristic.

```{r DE_lipid characteristics: differentially expressed analysis_Subgroup}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# subgroup deferentially expressed of lipid characters
DE.sub.char.2 <- DE_sub_char_2(exp_data, data_transform=TRUE,
                               lipid_char_table=lipid_char_table,
                               split_var = char_var[1],
                               char_var = char_var[4],
                               group_info = group_info,
                               paired=FALSE, sig_pvalue=0.05,
                               sig_FC=2, exclude_var_missing=TRUE,
                               missing_pct_limit=50,
                               replace_zero=TRUE, zero2what='min',
                               xmin=0.5, replace_NA=TRUE,
                               NA2what='min', ymin=0.5,
                               pct_transform=TRUE, trans_type='log',
                               centering=FALSE, scaling=FALSE)
# get class of characteristics
char.class <- unique(DE.sub.char.2[[2]][1])
# visualize subgroup deferentially expressed of lipid characters
sub_char_result <- DE_sub_char_plot_2(DE.sub.char.2[[2]],
                                      DE.sub.char.2[[3]],
                                      group_info=group_info,
                                      char_var=char_var[4],
                                      split_var=char_var[1],
                                      split_class=char.class[5,],
                                      insert_ref_group=NULL, ref_group=NULL)
```
* *Note: The star above the bar shows the significant difference of the specific subgroup of the selected characteristic between control and experimental groups.*
```{r , fig.cap = "The results of 'Subgroup of characteristics' analysis in the second section - bar plot"}
# view result: bar plot of split_class
sub_char_result[[1]]  
```
```{r , fig.cap = "The results of 'Subgroup of characteristics' analysis in the second section - sqrt-scaled bar plot"}
# view result: sqrt-scaled bar plot of split_class
sub_char_result[[4]]
```
```{r , fig.cap = "The results of 'Subgroup of characteristics' analysis in the second section - line plot"}
# view result: line plot of split_class
sub_char_result[[2]]
```
```{r , fig.cap = "The results of 'Subgroup of characteristics' analysis in the second section - sqrt-scaled line plot"}
# view result: sqrt-scaled line plot of split_class
sub_char_result[[5]] 
```
```{r , fig.cap = "The results of 'Subgroup of characteristics' analysis in the second section - box plot"}
# view result: box plot of split_class
sub_char_result[[3]] 
```

### Dimensionality reduction
Dimensionality reduction is common when dealing with large numbers of observations and/or large numbers of variables in lipids analysis. It transforms data from a high-dimensional space into a low-dimensional space to retain vital properties of the original data and close to its intrinsic dimension. Here, we provide 4 dimensionality reduction methods, namely, PCA, t-SNE, UMAP, and PLS-DA. For the detailed information of the former three methods, please refer to Section \@ref(DimensionReduce). 

#### PCA (Principal component analysis)
PCA is an unsupervised linear dimensionality reduction and data visualization technique for high dimensional data, which tries to preserve the global structure of the data. For detailed information of PCA, please refer to Section \@ref(PCA).
```{r DE_lipid characteristics: dimensionality reduction - PCA}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# sum expression data by selected characteristics
exp_data_Spe2Char <- Species2Char(exp_data, lipid_char_table,
                                  char_var = char_var[4])
# data processing of exp_data_Spe2Char
exp_transform_class <- data_process(exp_data_Spe2Char, 
                                    exclude_var_missing=TRUE, 
                                    missing_pct_limit=50, replace_zero=TRUE,
                                    zero2what='NA', xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data_Spe2Char,
                                      exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE,
                                      trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter significant lipid characteristics
DE_char_table_sig <- DE_char_2(exp_transform_non_log,
                               data_transform=TRUE,
                               group_info = group_info,
                               paired=FALSE, sig_pvalue=0.05,
                               sig_FC=2)$DE_char_table_all %>% 
                               filter(sig=="yes")
# conduct PCA
DEchar_PCA <- PCA(exp_transform_class, group_info = group_info,
                  sig_feature = DE_char_table_sig[,1],
                  scaling=TRUE, centering=TRUE,
                  cluster_method='kmeans',
                  group_num=2, var1 = NULL, var2 = NULL,
                  insert_ref_group=NULL, ref_group=NULL,
                  n_PC=c(1,2), top_n_feature=10)

# view result: PCA prcomp
head(DEchar_PCA[[1]], 2)

# view result: data frame of PCA rotated data
head(DEchar_PCA[[2]][,1:5], 5)

# view result: data frame of PCA contribution table
head(DEchar_PCA[[3]])
```

```{r , fig.cap = "Results of PCA - PCA plot"}
# view result: PCA plot 
DEchar_PCA[[4]]  
```
```{r , fig.cap = "Results of PCA - scree plot"}
# view result: scree plot
DEchar_PCA[[5]]   
```
```{r , fig.cap = "Results of PCA - bar plot"}
# view result: bar plot of features contribution
DEchar_PCA[[6]]
```
```{r , fig.cap = "Results of PCA - correlation circle plot"}
# view result: correlation circle plot of variables
DEchar_PCA[[7]]
```

#### t-SNE (t-distributed stochastic neighbour embedding)
t-Distributed Stochastic Neighbour Embedding (t-SNE) is an unsupervised non-linear dimensionality reduction technique that tries to retain the local structure(cluster) of data when visualising the high-dimensional datasets. For detailed information of t-SNE, please refer to Section \@ref(t-SNE).


```{r DE_lipid characteristics: dimensionality reduction - t-SNE}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# sum expression data by selected characteristics
exp_data_Spe2Char <- Species2Char(exp_data, lipid_char_table,
                                  char_var = char_var[4])
# data processing of exp_data_Spe2Char
exp_transform_class <- data_process(exp_data_Spe2Char, 
                                    exclude_var_missing=TRUE,
                                    missing_pct_limit=50, replace_zero=TRUE,
                                    zero2what='NA', xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data_Spe2Char,
                                      exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE,
                                      trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter significant lipid characteristics
DE_char_table_sig <- DE_char_2(exp_transform_non_log,
                               data_transform=TRUE,
                               group_info = group_info,
                               paired=FALSE, sig_pvalue=0.05,
                               sig_FC=2)$DE_char_table_all %>% 
                               filter(sig=="yes")
# conduct t-SNE
DEchar_tsne <- tsne(exp_transform_class, group_info = group_info,
                    sig_feature=DE_char_table_sig[,1],
                    pca=TRUE, perplexity=5, max_iter=500,
                    cluster_method='kmeans', group_num=2,
                    var1 = 'euclidean', var2=NULL,
                    insert_ref_group=NULL, ref_group=NULL)

# view result: data frame of t-SNE data
head(DEchar_tsne[[1]], 5)
```

```{r , fig.cap = "t-SNE plot"}
# view result: t-SNE plot
DEchar_tsne[[2]]  
```

#### UMAP (Uniform Manifold Approximation and Projection)
UMAP using a nonlinear dimensionality reduction method, Manifold learning, which effectively visualizing clusters or groups of data points and their relative proximities. For detailed information of UMAP, please refer to Section \@ref(UMAP).

```{r DE_lipid characteristics: dimensionality reduction - UMAP}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# sum expression data by selected characteristics
exp_data_Spe2Char <- Species2Char(exp_data, lipid_char_table,
                                  char_var = char_var[4])
# data processing of exp_data_Spe2Char
exp_transform_class <- data_process(exp_data_Spe2Char, 
                                    exclude_var_missing=TRUE,
                                    missing_pct_limit=50, replace_zero=TRUE,
                                    zero2what='NA', xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data_Spe2Char,
                                      exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE,
                                      trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter significant lipid characteristics
DE_char_table_sig <- DE_char_2(exp_transform_non_log,
                               data_transform=TRUE,
                               group_info = group_info,
                               paired=FALSE, sig_pvalue=0.05,
                               sig_FC=2)$DE_char_table_all %>% 
                               filter(sig=="yes")
# conduct UMAP
DEchar_UMAP <- UMAP(exp_transform_class, group_info = group_info,
                    sig_feature = DE_char_table_sig[,1],
                    n_neighbors=15, scale=TRUE, group_num=2,
                    metric = 'euclidean',
                    cluster_method = 'kmeans',
                    var1=NULL, var2=NULL,
                    insert_ref_group=NULL, ref_group=NULL)

# view result: data frame of UMAP data
head(DEchar_UMAP[[1]], 5)
```

```{r , fig.cap = "UMAP plot"}
# view result: UMAP plot
DEchar_UMAP[[2]] 
```

#### PLS-DA
```{r DE_lipid characteristics: dimensionality reduction - PLS-DA}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# sum expression data by selected characteristics
exp_data_Spe2Char <- Species2Char(exp_data, lipid_char_table,
                                  char_var = char_var[4])
# data processing of exp_data_Spe2Char
exp_transform_class <- data_process(exp_data_Spe2Char, 
                                    exclude_var_missing=TRUE,
                                    missing_pct_limit=50, replace_zero=TRUE,
                                    zero2what='NA', xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data_Spe2Char,
                                      exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      replace_zero=TRUE,
                                      zero2what='min', xmin=0.5,
                                      replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE,
                                      trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter significant lipid characteristics
DE_char_table_sig <- DE_char_2(exp_transform_non_log,
                               data_transform=TRUE,
                               group_info = group_info,
                               paired=FALSE, sig_pvalue=0.05,
                               sig_FC=2)$DE_char_table_all %>% 
                               filter(sig=="yes")
# conduct PLSDA
DEchar_PLSDA <- PLSDA(exp_transform_class, group_info = group_info,
                      sig_feature=DE_char_table_sig[,1],
                      ncomp=2, scaling=TRUE, cluster_method='group_info',
                      group_num = NULL, var1=NULL, var2=NULL,
                      insert_ref_group=NULL, ref_group=NULL)

# view result: data frame of sample variate
head(DEchar_PLSDA[[1]], 5)

# view result: data frame of sample loading
head(DEchar_PLSDA[[2]])
```
```{r , fig.cap = "PLS-DA sample plot"}
# view result: PLS-DA sample plot
DEchar_PLSDA[[3]]  
```

```{r , fig.cap = "PLS-DA loading plot. In the PLS-DA loading plot, the distance to the center of the variables indicates the contribution of the variable. The value of the x-axis reveals the contribution of the variable to PLS-DA-1, whereas the value of the y-axis discloses the contribution of the variable to PLS-DA-2."}
# view result: PLS-DA loading plot
DEchar_PLSDA[[4]]
```

### Hierarchical clustering
A new lipid expression table summed up from species is clustered and shown on the heatmap using hierarchical clustering.
```{r DE_lipid characteristics: hierarchical clustering}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# sum expression data by selected characteristics
exp_data_Spe2Char <- Species2Char(exp_data, lipid_char_table,
                                  char_var = char_var[4])
# data processing of exp_data_Spe2Char
exp_transform_class <- data_process(exp_data_Spe2Char, 
                                    exclude_var_missing=TRUE,
                                    missing_pct_limit=50, replace_zero=TRUE,
                                    replace_NA=TRUE,zero2what='NA',
                                    NA2what='min', pct_transform=TRUE, 
                                    xmin=0.5, data_transform=TRUE, 
                                    ymin=0.5, trans_type='log', 
                                    centering=FALSE, scaling=FALSE)
# data processing of exp_data (without log10 transformation)
exp_transform_non_log <- data_process(exp_data_Spe2Char,
                                      exclude_var_missing=TRUE,
                                      missing_pct_limit=50,
                                      replace_zero=TRUE, zero2what='min',
                                      xmin=0.5, replace_NA=TRUE, NA2what='min',
                                      ymin=0.5, pct_transform=TRUE,
                                      data_transform=FALSE, trans_type='log',
                                      centering=FALSE, scaling=FALSE)
# filter significant lipid characteristics
DE_char_table_sig <- DE_char_2(exp_transform_non_log,
                               data_transform=TRUE, group_info = group_info,
                               paired=FALSE, sig_pvalue=0.05, sig_FC=2
                              )$DE_char_table_all %>% filter(sig=="yes")
# conduct hierarchical clustering
DEchar_Hcluster <- Hclustering(exp_transform_class, DE_char_table_sig,
                               group_info, lipid_char_table=NULL, 
                               char_var=NULL, distfun='pearson', 
                               hclustfun='complete')

# view result: matrix of all lipid species heatmap
head(DEchar_Hcluster$all.lipid.data[, 1:5], 5)

# view result: matrix of significant lipid species heatmap
head(DEchar_Hcluster$sig.lipid.data[, 1:5])
```

```{r , fig.cap = "Heatmap of hierarchical clustering"}
# view result: heatmap of all lipid species
DEchar_Hcluster$all.lipid  

# view result: heatmap of significant lipid species
DEchar_Hcluster$sig.lipid 
```
Through heatmap of lipid characteristic expression differences between the control group and the experimental group, we may discover the difference between the two groups by observing the distribution of lipid characteristic expression. Columns are all samples and rows are the significant characteristic group (value) selected from the first 'Characteristics' section (Section \@ref(sec:DE-char) ).

# Machine learning {#ML}
After identifying significant lipid species and lipids characteristics, now we are going to conduct machine learning for feature selection and then view the importance of each feature. Lipid species and lipid characteristics data will be combined to predict the binary outcome using various machine learning methods and select the best feature combination to explore further relationships. For cross-validation, Monte-Carlo cross-validation (MCCV) is executed to evaluate the model performance and to reach statistical significance.

Monte-Carlo cross-validation is a model validation technique that we used to create multiple random splits of the dataset into training and validation data, which prevent an unnecessary large model and thus prevent over-fitting for the calibration model [@xu2001monte]. With MCCV, we can conduct a split-sample CV multiple times and aggregate the results from each to quantify predictive performance for a candidate mode. For each CV, data is randomly split into training and testing data. The training data is used to select the top 2, 3, 5, 10, 20, 50, and 100 important features for model training. Then, the model will be validated by testing data. If the data are less than 100 features, the total feature number is set as the maximum. The proportion of data used for testing and the times of cross-validation (CV) and can be defined by the parameters `split_prop` and `nfold`. *(Note: The more cross-validation times are, the longer it takes to calculate the results.)*

Feature selection methods are aimed to rank the most significant variables to a model to predict the target variable. Our platform provides two categories of feature selection methods: the univariate and the multivariate analysis. Univariate analysis, including p-value, p-value\*Fold Change or ROC, compares each feature between two groups and picks top N features based on -log10(p-value), –log10(p-value)\*Fold change or Area Under Curve (AUC), respectively according to the user-selected ranking methods. On the other hand, for multivariate analysis, we offer Random Forest, Linear SVM (e1071), Lasso (glmnet), Ridge (glmnet), and ElasticNet (glmnet). Random Forest (ranger) uses built-in feature importance results, while others rank the features according to the absolute value of their coefficients in the algorithm. *(Note: The names in the bracket are the packages we adopt.)*

Here, we provide eight feature ranking methods and six classification methods for training and selecting the best model.
* **Feature ranking methods**: p-value, p-value*FC, ROC, Random Forest, Linear SVM, Lasso, Ridge, ElasticNet.
* **Classification methods**: Random Forest, Linear SVM, Lasso, Ridge, ElasticNet, XGBoost.
Furthermore, we will conduct a series of consequent analyses to evaluate the methods and visualize the results of machine learning, including ROC/PR curve, model predictivity, sample probability, feature importance, and network.

## Input data
First, we have to read the input data needed for the machine learning section. We have to prepare lipid expression data (`exp_data`), lipid characteristics table (`lipid_char_table`), and a condition table of sample names and clinical conditions (`condition_table`) as input data.
```{r load_ML_data}
# clears all objects from workspace
rm(list = ls())

# lipid expression data
data("ML_exp_data")
exp_data <- ML_exp_data
head(exp_data[, 1:5], 5)

# lipid characteristics table
data("ML_lipid_char_table")
lipid_char_table <- ML_lipid_char_table
head(lipid_char_table[, 1:4], 5)

# condition table
data("ML_condition_table")
condition_table <- ML_condition_table
head(condition_table, 5)
```
After importing the input data, sometimes, we may need to conduct data processing before analysis. Here, we provide the `ML_data_process` function for data processing, including removing features with missing values, missing values imputation, percentage transformation, log10 transformation, etc. 
```{r ML_data_process}
# lipid expression data
head(exp_data[, 1:5], 5)
# data processing of exp_data
exp_transform_table <- data_process(exp_data, exclude_var_missing=TRUE,
                                    missing_pct_limit=50, replace_zero=TRUE,
                                    zero2what='min', xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# exp_data after data processing
head(exp_transform_table[, 1:5], 5)
```

## ROC/PR curve
The ROC and Precision-Recall (PR) curves are very common methods to evaluate the diagnostic ability of a binary classifier. The mean AUC and 95% confidence interval of the ROC and PR curve are calculated from all CV runs in each feature number. Theoretically, the higher the AUC is, the better the model performs. PR curve is more sensitive to data with highly skewed datasets (i.e., rare positive samples), and offers a more informative view of an algorithm's performance [@davis2006relationship]. A random classifier yields a ROC-AUC about 0.5 and a PR-AUC close to a positive sample proportion. On the contrary, both AUC equal to 1 represents perfect performance in two methods.

Speaking of interpreting plots, the ROC curve is created with 'sensitivity' (proportion of positive samples that are correctly classified) as y-axis and '1-specificity' (proportion of negative samples that are correctly classified) as x-axis based on different thresholds whereas the PR curve is a similar graph with 'precision' (proportion of positive samples out of those that are predicted positive) on the y-axis and 'recall' (=sensitivity) on the x-axis. Generally, a better model shows a ROC curve approaching the left upper corner and a PR curve around the right upper corner.

To combine the testing results from all CV runs, 300 thresholds are evenly distributed from 0 to 1. The thresholds are then calculated the corresponding sensitivity, specificity, precision, and recall with predicted probabilities and true labels of testing samples in each CV. These values are then averaged to plot a final ROC and PR curve.

Now, we are going to conduct calculation for plotting ROC curves first,  and then the PR curves.
```{r ML: ROC curve}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, missing_pct_limit=50,
                           replace_zero=TRUE, zero2what='min', xmin=0.5,
                           replace_NA=TRUE, NA2what='min', ymin=0.5,
                           pct_transform=TRUE, data_transform=TRUE,
                           trans_type='log', centering=FALSE, scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]],ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# ROC curves
ROC_result <- ROC_plot_all(ML_output[[3]], ML_output[[5]], feature_n=10)

# view result: ROC data frame of 10 features
head(ROC_result[[3]][, 1:5], 5)

# view result: data frame of ROC values
head(ROC_result[[1]][, 1:5], 5)
```

```{r , fig.cap= 'ROC curve plot. The plot shows the average ROC curve for different feature numbers with their mean AUC and 95% confidence interval.', fig.width=7}
# view result: ROC curve plot
ROC_result[[2]]
```

```{r , fig.cap= 'average ROC curve plot of 10 features. The plot displays average ROC curves of user-defined features. Each CV is in grey, and the red line is the average of those cross-validations (CVs) for the ROC curves.'}
# view result: average ROC curve plot of 10 features
ROC_result[[4]]   
```

```{r ML: PR curve}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
## data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, missing_pct_limit=50,
                           replace_zero=TRUE, zero2what='min', xmin=0.5,
                           replace_NA=TRUE, NA2what='min', ymin=0.5,
                           pct_transform=TRUE, data_transform=TRUE,
                           trans_type='log', centering=FALSE, scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]],ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# PR curves
PR_result <- PR_plot_all(ML_output[[4]], ML_output[[5]], feature_n=10)

# view result: data frame of precision and recall values
head(PR_result[[1]][, 1:5], 5)

# view result: data frame of PR values
head(PR_result[[3]][, 1:5], 5)
```

```{r , fig.cap= 'PR curve plot. The plot shows the average PR curve for different feature numbers with their mean AUC and 95% confidence interval.', fig.width=7}
# view result: PR curve plot
PR_result[[2]]
```

```{r , fig.cap= 'average PR curve plot of 10 features. The plot displays the average PR curves of user-defined features. Each CV is in grey, and the red line is the average of those cross-validations (CVs) for the PR curves.'}
# view result: average PR curve plot of 10 features
PR_result[[4]]    
```


## Model performance
After constructing the model, it is necessary to evaluate the performance of our model. Here, we provide many useful indicators to evaluate model performance. For each feature number, we calculate and plot the average value and 95% confidence interval of accuracy, sensitivity (recall), specificity, positive predictive value (precision), negative predictive value, F1 score, prevalence, detection rate, detection prevalence, and balanced accuracy in all CV runs with confusion matrix function in carat package. All these indicators can be described in terms of true positive (TP), false positive (FP), false negative (FN), and true negative (TN).

Here, all the provided evaluation indicators are listed below. We can define the evaluation method by the parameter `method`.

* Sensitivity = Recall $= \frac{TP}{(TP + FN)}$

* Specificity $= \frac{TN}{(FP + TN)}$

* Prevalence $= \frac{(TP + FN)}{(TP + FP + FN + TN)}$

* Positive predictive value (PPV) = Precision $= \frac{TP}{(TP + FP)}$

* Negative predictive value (NPV) $= \frac{TN}{(FN + TN)}$

* Detection rate $= \frac{TP}{(TP + FP + FN + TN)}$

* Detection prevalence $= \frac{(TP + FP)}{(TP + FP + FN + TN)}$

* F1 score $= \frac{2 \times Precision \times Recall}{(Precision + Recall)}$

```{r ML: model performance}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, missing_pct_limit=50,
                           replace_zero=TRUE, zero2what='min', xmin=0.5,
                           replace_NA=TRUE, NA2what='min', ymin=0.5,
                           pct_transform=TRUE, data_transform=TRUE,
                           trans_type='log', centering=FALSE, scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]], ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# conduct model evaluation
evaluate_result <- evalution_plot(ML_output[[2]], method='Accuracy')

# view result: data frame of model evaluation information
head(evaluate_result[[1]][, 1:5], 5)
```
```{r , fig.cap = "Model performance (Accuracy). The evaluation plot shows the model performance of accuracy. The highest value is marked in red."}
# view result: model performance plot
evaluate_result[[2]]         
```


## Predicted probability
The average predicted probabilities of each sample in testing data from all CV runs assist us to explore those incorrect or uncertain labels.
```{r ML: predicted probability}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, missing_pct_limit=50,
                           replace_zero=TRUE, zero2what='min', xmin=0.5,
                           replace_NA=TRUE, NA2what='min', ymin=0.5,
                           pct_transform=TRUE, data_transform=TRUE,
                           trans_type='log', centering=FALSE, scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]], ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# compute and visualize the average predicted probabilities
prob_result <- probability_plot(ML_output[[1]], feature_n=10)

# view result: data frame of confusion matrix
head(prob_result[[1]][, 1:5], 5)

# view result: data frame of predicted probability and labels
head(prob_result[[4]][, 1:5], 5)
```
```{r , fig.cap = "Probability plot. In the plot of average sample probability in all CVs’ distribution, each point represents a sample, which is the mean of the prediction from all models of all Cross Validations. The y-axis is the predicted probabilities of the samples, which means the probability that the prediction value of each machine learning model is one. To depict in detail, the blue group of samples shows the probabilities that the true value is one and the prediction value of the sample is also one. The black group illustrates the probabilities that the true value is zero and the prediction value of the sample is also one. Hence, the Black group should be as close to zero, whereas the blue group should be as close to one as possible."}
# view result: the distribution of predicted probabilities
prob_result[[2]]
```

```{r , fig.cap = "Confusion matrix. In the confusion matrix, the y-axis indicates the predicted class, the x-axis is the actual class. Therefore, the upper left is a true positive; the upper right is a false positive; the lower left is a false negative; the lower right is a true negative. The numbers are the count and the number in the bracket is the percentage."}
# view result: confusion matrix of sample number and proportion
prob_result[[3]]        
```


## Feature importance {#subsec:feature_im}
After building a high-accuracy model, now we are going to explore the contribution of each feature. Two methods, **'Algorithm-based'** and **'SHAP analysis'** are provided to rank and visualize the feature importance.

### Algorithm-based
In the **'Algorithm-based'** part, when we set a certain feature number by parameter `feature_n`, the selected frequency and the average feature importance of the top 10 features from all CV runs will be displayed. For a Linear SVM, Lasso, Ridge, or ElasticNet model, the importance of each feature depends on the absolute value of their coefficients in the algorithm, while Random Forest and XGBoost use built-in feature importance results.
```{r ML: feature importance_algorithm-based}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, missing_pct_limit=50,
                           replace_zero=TRUE, zero2what='min', xmin=0.5,
                           replace_NA=TRUE, NA2what='min', ymin=0.5,
                           pct_transform=TRUE, data_transform=TRUE,
                           trans_type='log', centering=FALSE, scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]], ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# compute and rank the contribution of each feature
feature_result <- feature_plot(ML_output[[6]], ML_output[[7]],
                               feature_n=10, nfold=10)

# view result: data frame of the selected frequency
head(feature_result[[1]][, 1:5], 5)

# view result: data frame of feature importance
head(feature_result[[3]][, 1:5], 5)
```
```{r , fig.cap = "Feature importance (Algorithm-based)-selected frequency"}
# view result: selected frequency plot
feature_result[[2]]
```
```{r , fig.cap = "Feature importance (Algorithm-based)-feature importance"}
# view result: feature importance plot
feature_result[[4]] 
```

### SHAP analysis
Shapley Additive exPlanations (SHAP) approach on the basis of Shapley values in game theory has recently been introduced to explain individual predictions of any machine learning model. More detailed information can be found in the paper 'A Unified Approach to Interpreting Model Predictions' (2017) [@lundberg2017unified]. 
    
The analysis is based on the result of ROC-AUC and PR-AUC. We can decide the feature number by parameter `feature_n`. According to the defined feature number, the corresponding best model in all CVs will be used to compute approximate Shapley values of each feature for all samples with 'fastshap' package in R.

```{r ML: SHAP analysis}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, missing_pct_limit=50,
                           replace_zero=TRUE, zero2what='min', xmin=0.5,
                           replace_NA=TRUE, NA2what='min', ymin=0.5,
                           pct_transform=TRUE, data_transform=TRUE,
                           trans_type='log', centering=FALSE, scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]], ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# conduct SHAP
SHAP_output <- SHAP(ML_data[[2]], best_model=ML_output[[8]],
                    best_model_feature=ML_output[[9]],
                    ML_method='Random_forest', feature_n=10, nsim=5)
```
```{r , fig.cap = "SHAP feature importance plot. The top 10 features are ranked and demonstrated according to the average absolute value of shapely values from all samples."}
# view result: SHAP feature importance plot
SHAP_output[[3]]
```

```{r , fig.cap = "SHAP feature importance plot. The SHAP summary plot illustrates the distribution of all shapely values for each feature. It uses sina plot to present important features by binary patterns. The color exemplifying the value of the feature from low (yellow) to high (purple) indicates the variable is high/low for that observation. The x-axis presents whether the impact is positive or negative on quality rating (target variable). In the summary plot, the relationship between the value of a feature and the influence on the prediction is shown."}
# view result: SHAP summary plot
SHAP_output[[4]] 
```

Next, we are going to visualize the SHAP feature importance of N samples.
```{r ML: SHAP analysis_sample}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, pct_transform=TRUE,
                           missing_pct_limit=50, replace_zero=TRUE,
                           zero2what='min', NA2what='min',
                           xmin=0.5, replace_NA=TRUE, ymin=0.5,
                           data_transform=TRUE, centering=FALSE,
                           trans_type='log', scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]], ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# conduct SHAP
SHAP_output <- SHAP(ML_data[[2]], best_model=ML_output[[8]],
                    best_model_feature=ML_output[[9]], nsim=5,
                    ML_method='Random_forest', feature_n=10)
# visualize SHAP feature importance of 10 samples
SHAP_sample_result <- SHAP_sample(SHAP_output[[2]], n_sample=10)
```
```{r , fig.cap = "SHAP feature importance of 10 samples"}
# view result: SHAP feature importance plot of 10 samples
SHAP_sample_result      
```
Lastly, we build the SHAP force plot and dependence plot with different parameter sets.

The SHAP force plot stacks these Shapley values and shows how the selected features affect the final output for each sample. We can decide the number of top features to be shown by parameter `topN_feature`, and the number of groups the samples to be clustered into by parameter `group_num`. 
```{r ML: SHAP analysis_forceplot}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, missing_pct_limit=50,
                           replace_zero=TRUE, zero2what='min', xmin=0.5,
                           replace_NA=TRUE, NA2what='min', ymin=0.5,
                           pct_transform=TRUE, data_transform=TRUE,
                           trans_type='log', centering=FALSE, scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]], ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# conduct SHAP
SHAP_output <- SHAP(ML_data[[2]], best_model=ML_output[[8]],
                    best_model_feature=ML_output[[9]],
                    ML_method='Random_forest', feature_n=10, nsim=5)
# visualize each predictor’s attributions
SHAP_force_result <- SHAP_forceplot(SHAP_output[[1]], topN_feature=10,
                                    cluster_method="ward.D", group_num=10)

# view result: data frame of force plot information
head(SHAP_force_result[[1]][, 1:5], 5)
```
```{r , fig.cap = "SHAP force plot. The colors of the bars are filled according to the features."}
# view result: SHAP force plot
SHAP_force_result[[2]] 
```

As to the SHAP dependence plot, it allows us to explore how the model output varies by a feature value. It reveals whether the link between the target and the variable is linear, monotonic, or more complex.

We can define the x-axis, y-axis, and color of the plot. Generally, the x-axis represents the value of a certain feature while the y-axis is the corresponding Shapley value. The color parameter can be assigned to check if a second feature has an interaction effect with the feature we are plotting.
```{r ML: SHAP analysis_dependence_plot}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, missing_pct_limit=50,
                           replace_zero=TRUE, zero2what='min', xmin=0.5,
                           replace_NA=TRUE, NA2what='min', ymin=0.5,
                           pct_transform=TRUE, data_transform=TRUE,
                           trans_type='log', centering=FALSE, scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]], ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# conduct SHAP
SHAP_output <- SHAP(ML_data[[2]], best_model=ML_output[[8]],
                    best_model_feature=ML_output[[9]], nsim=5,
                    ML_method='Random_forest', feature_n=10)
# visualize SHAP values against feature values for each variable
SHAP_depend_result <- SHAP_dependence_plot(SHAP_output[[2]], x="C38.6.PC",
                                           y="C38.6.PC", color_var="C38.6.PC")

```
```{r , fig.cap = "SHAP dependence plot"}
# view result: SHAP dependence plot
SHAP_depend_result 
```

## Network
A correlation network helps us interrogate the interaction of features in a machine learning model. We can decide on an appropriate feature number according to previous cross-validation results. Then, the features in the best model (based on ROC-AUC + PR-AUC) are used to compute the correlation coefficients between each other.
    
To build a network, nodes (features) are filled based on feature importance whereas line width represents the value of the correlation coefficient. Two methods, ‘Algorithm-based’ and ‘SHAP analysis’, can be selected to evaluate feature importance. The detailed information about them can be found in the Feature importance section (Section \@ref(subsec:feature_im) ). A plus or minus are assigned to feature importance in SHAP analysis based on the direction of feature values and Shapley values of samples.
```{r ML: network}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# data processing of machine learning
ML_data <- ML_data_process(exp_data, group_info = condition_table,
                           lipid_char_table, char_var[1],
                           exclude_var_missing=TRUE, missing_pct_limit=50,
                           replace_zero=TRUE, zero2what='min', xmin=0.5,
                           replace_NA=TRUE, NA2what='min', ymin=0.5,
                           pct_transform=TRUE, data_transform=TRUE,
                           trans_type='log', centering=FALSE, scaling=FALSE)
# conduct machine learning
ML_output <- ML_final(ML_data[[2]], ranking_method='Random_forest',
                      ML_method='Random_forest', split_prop=0.3, nfold=10)
# select feature importance from model of ML_output
model_net <- model_for_net(ML_data[[2]], ML_method='Random_forest',
                           varimp_method='Algorithm-based', ML_output[[8]],
                           ML_output[[9]], feature_num=10, nsim=5)
# compute correlation coefficients and visualize correlation network
cor_net_result <- cor_network(ML_data[[1]], lipid_char_table,
                              model_net[[2]], model_net[[3]],
                              cor_method='pearson', edge_cutoff=0)
```
```{r , fig.cap = "The network of feature importance", result='asis'}
# view result: the network of feature importance
cor_net_result  
```


# Correlation analysis {#corr}
In the final part, we are going conduct a comprehensive correlation analysis to interrogate the clinical features that connect to lipids species and other mechanistically relevant lipid characteristics. Correlation analysis between lipids and clinical features is broadly used in many fields of study, such as Bowler RP et al. discovering that sphingomyelins are strongly associated with emphysema and glycosphingolipids are associated with COPD exacerbations [@bowler2015plasma]. 
    
The correlation analysis can be conducted by **"lipid species"** or **"lipid characteristics"**. In lipid species analysis, data are analyzed by lipid species. As to lipid characteristics analysis, the expression of all lipid species in the same categories of a selected characteristic is summed up for analysis. 
    
This section is designed for continuous clinical data. Two correlation analyses are accessible, **'Correlation Coefficient'** and **'Linear Regression'**. A heatmap will be shown once the correlation analysis is completed, it depicts the pattern between lipid species/lipid characteristics and clinical features. 
    
The available clustering methods are as follows. 

* Distance measurement: Pearson, Spearman, Kendall, Euclidean, Maximum, Manhattan, Canberra, Binary, and Minkowski.
* Clustering method: median, average, single, complete, Ward.D, Ward.D2, WPGMA, and UPGMC

## Input data
First, we have to read the input data needed for the correlation analysis section. We have to prepare lipid expression data (`exp_data`), lipid characteristics table (`lipid_char_table`), a condition table of sample names and clinical conditions (`condition_table`), and an adjusted table with additional variables for adjusting confounding effects (`adjusted_table`) as input data.
```{r load_correlation_data}
# clears all objects from workspace
rm(list = ls())

# lipid expression data
data("corr_exp_data")
exp_data <- corr_exp_data
head(exp_data[, 1:5], 5)

# lipid characteristics table
data("corr_lipid_char_table")
lipid_char_table <- corr_lipid_char_table
head(lipid_char_table, 5)

# condition table (clinical factor)
data("corr_condition_table")
condition_table <- corr_condition_table
head(condition_table,  5)

# adjusted table
data("corr_adjusted_table")
adjusted_table <- corr_adjusted_table
head(adjusted_table, 5)
```
After importing the input data, sometimes, we may need to conduct data processing before analysis. Here, we provide the `data_process` function for data processing, including removing features with missing values, missing values imputation, percentage transformation, log10 transformation, etc.
```{r corrrelation_data_process}
# lipid expression data
head(exp_data[, 1:5], 5)
# data processing of exp_data
exp_transform_table <- data_process(exp_data, exclude_var_missing=TRUE,
                                    missing_pct_limit=50, replace_zero=TRUE,
                                    zero2what='min', xmin=0.5, 
                                    replace_NA=TRUE, NA2what='min', 
                                    ymin=0.5, pct_transform=TRUE,
                                    data_transform=TRUE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# exp_data after data processing
head(exp_transform_table[, 1:5], 5)
```

## Lipid species analysis
The following correlation analysis is conducted after lipids classified by lipid species.

### Correlation {#correlation}
The Correlation Coefficient gives a summary view that tells us whether a relationship exists between clinical features and lipid species, how strong that relationship is, and whether the relationship is positive or negative. We can decide the cut-offs for the correlation coefficient and the p-value by parameter `sig_cor_coef` and `sig_pvalue`. The rule of thumb in medical research recommended by Mukaka for interpreting the size of a correlation coefficient is provided below [@mukaka2012guide].


Size of Correlation          | Interpretation                             
-----------------------------|--------------------------------------------                   
0.90 to 1.00 (-.90 to -1.00) | Very high positive (negative) correlation
0.70 to .90 (-.70 to -.90)   | High positive (negative) correlation 
0.50 to .70 (-.50 to -.70)   | Moderate positive (negative) correlation
0.30 to .50 (-.30 to -.50)   | Low positive (negative) correlation     
0.00 to .30 (.00 to -.30)    | negligible correlation


```{r Correlation_lipid species: correlation}
# data processing of exp_data
exp_transform <- data_process(exp_data, exclude_var_missing=TRUE,
                              missing_pct_limit=50,
                              replace_zero=TRUE, zero2what='min',
                              xmin=0.5, replace_NA=TRUE,
                              NA2what='min', ymin=0.5,
                              pct_transform=TRUE, data_transform=TRUE,
                              trans_type='log', centering=FALSE, scaling=FALSE)
# compute correlation coefficient and visualize by heatmap
COspec_clinCor <- Clin_Cor_heatmap(exp_transform, condition_table,
                                   test = 'pearson', adjust_p_method = 'BH',
                                   sig_stat = 'p.adj', sig_pvalue=1,
                                   sig_cor_coef=0, heatmap_col='statistic',
                                   distfun='spearman', hclustfun='average')

# view result: data frame of clinical features and lipid species
head(COspec_clinCor$Cor_table_all[, 1:5], 5)

# view result: data frame of significant clinical features and lipid species
head(COspec_clinCor$Cor_table_sig[, 1:5], 5)

# view result: clinical features and lipid species correlation reorder matrix
head(COspec_clinCor$Cor_reorder_mat[, 1:2])
```

```{r , fig.cap = "Correlation coefficient for lipid species analysis. Only the variables that pass the defined cut-offs for p-value and the correlation coefficient are shown on the heatmap. The rows of the heatmap are clinical features and the columns are the lipid species."}
# view result: heatmap of clinical features and lipid species
COspec_clinCor$Cor_table_plot 
```


### Linear regression {#corr:LR}
Linear regression is a statistical technique that uses several explanatory variables to predict the outcome of a continuous response variable, allowing us to estimate the associations between lipid levels and clinical features. In multiple linear regression analysis, additional variables from the 'adjusted table' are added to the algorithm for adjusting the confounding effect. Once the calculation completes, a beta coefficient and t statistic (p-value) will be assigned to each lipid species, which can be chosen for clustering.
```{r Correlation_lipid species: linear regression}
# data processing of exp_data
exp_transform <- data_process(exp_data, exclude_var_missing=TRUE,
                              missing_pct_limit=50, replace_zero=TRUE,
                              zero2what='min', xmin=0.5, replace_NA=TRUE,
                              NA2what='min', ymin=0.5, pct_transform=TRUE,
                              data_transform=TRUE, trans_type='log',
                              centering=FALSE, scaling=FALSE)
# compute linear regression and visualize by heatmap
COspec_clin_LR <- Clin_LR_heatmap(exp_transform, condition_table,
                                  adjusted_table, adjust_p_method = 'BH',
                                  sig_stat = 'p.adj', sig_pvalue = 1,
                                  distfun='spearman', hclustfun='centroid',
                                  heatmap_col='beta_coef')

# view result: data frame of statistical results
head(COspec_clin_LR$LR_table_all[, 1:4], 5)

# view result: data frame of significant statistical results
head(COspec_clin_LR$LR_table_sig[, 1:4], 5)

# view result: matrix of heatmap
head(COspec_clin_LR$LR_reorder_mat[, 1:2])
```

```{r , fig.cap = "The heatmap of linear regression for lipid species analysis. Only the variables that pass the user-defined cut-offs for p-value and the correlation coefficient are shown on the heatmap. The rows of the heatmap are clinical features and the columns are the lipid species."}
# view result: heatmap of linear regression
COspec_clin_LR$LR_table_plot  
```

## Lipid characteristics analysis
The following correlation analysis is conducted after lipids are classified by lipid characteristics from the 'Lipid characteristics' table.

### Correlation
This section provides the correlation of lipid characteristics analysis. The Correlation Coefficient gives a summary view that tells us whether a relationship exists between clinical features and lipid species, how strong that relationship is, and whether the relationship is positive or negative. We can decide the cut-offs for the correlation coefficient and the p-value by parameter `sig_cor_coef` and `sig_pvalue`. The rule of thumb in medical research recommended by Mukaka for interpreting the size of a correlation coefficient is provided below [@mukaka2012guide].

Size of Correlation          | Interpretation                             
-----------------------------|--------------------------------------------                   
0.90 to 1.00 (-.90 to -1.00) | Very high positive (negative) correlation
0.70 to .90 (-.70 to -.90)   | High positive (negative) correlation 
0.50 to .70 (-.50 to -.70)   | Moderate positive (negative) correlation
0.30 to .50 (-.30 to -.50)   | Low positive (negative) correlation     
0.00 to .30 (.00 to -.30)    | negligible correlation

```{r Correlation_lipid characteristics: correlation}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# aggregated(sum) expression data by selected characteristics
exp_data_Spe2Char <- Species2Char(exp_data, lipid_char_table,
                                  char_var = char_var[1])
# data processing of exp_data_Spe2Char
exp_transform_class <- data_process(exp_data_Spe2Char, 
                                    exclude_var_missing=TRUE,
                                    missing_pct_limit=50, replace_zero=TRUE,
                                    zero2what='NA', xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=FALSE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# compute correlation coefficient and visualize by heatmap
COchar_clinCor <- Clin_Cor_heatmap(exp_transform_class, condition_table,
                                   test = 'pearson', adjust_p_method = 'BH',
                                   sig_stat = 'p.adj', sig_pvalue=1,
                                   sig_cor_coef=0, heatmap_col='statistic',
                                   distfun='spearman', hclustfun='average')

# view result: data frame of clinical features and lipid characteristics
head(COchar_clinCor$Cor_table_all[, 1:5], 5)

# view result: data frame of significant clinical features and lipid characteristics
head(COchar_clinCor$Cor_table_sig[, 1:5], 5)

# view result: clinical features and lipid characteristics correlation reorder matrix
head(COchar_clinCor$Cor_reorder_mat[, 1:2])
```

```{r , fig.cap = "Correlation coefficient for lipid characteristics analysis. Only the variables that pass the defined cut-offs for p-value and the correlation coefficient are shown on the heatmap. The rows of the heatmap are clinical features and the columns are lipid characteristics."}
# view result: heatmap of clinical features and lipid characteristics
COchar_clinCor$Cor_table_plot 
```


### Linear regression
This section provides the linear regression of lipid characteristics analysis. Linear regression is a statistical technique that uses several explanatory variables to predict the outcome of a continuous response variable, allowing us to estimate the associations between lipid levels and clinical features. Lipids are classified and summed by the user-selected lipid characteristics (e.g., class), then implementing univariate or multivariate linear regression analysis with whether ‘adjusted table’ is provided. Each component in the selected characteristics will be assigned a beta coefficient and t statistic (p-value), which can be chosen for clustering.

```{r Correlation_lipid characteristics: linear regression}
# get lipid characteristics
char_var <- colnames(lipid_char_table)[-1]
# aggregated(sum) expression data by selected characteristics
exp_data_Spe2Char <- Species2Char(exp_data, lipid_char_table,
                                  char_var = char_var[1])
# data processing of exp_data_Spe2Char
exp_transform_class <- data_process(exp_data_Spe2Char, 
                                    exclude_var_missing=TRUE,
                                    missing_pct_limit=50, replace_zero=TRUE,
                                    zero2what='NA', xmin=0.5, replace_NA=TRUE,
                                    NA2what='min', ymin=0.5, 
                                    pct_transform=TRUE,
                                    data_transform=FALSE, trans_type='log',
                                    centering=FALSE, scaling=FALSE)
# compute linear regression and visualize by heatmap
COchar_clin_LR <- Clin_LR_heatmap(exp_transform_class, condition_table,
                                  adjusted_table, adjust_p_method = 'BH',
                                  sig_stat = 'p.adj', sig_pvalue = 1,
                                  distfun='spearman', hclustfun='centroid',
                                  heatmap_col='beta_coef')

# view result: data frame of statistical results
head(COchar_clin_LR$LR_table_all[, 1:4], 5)

# view result: data frame of significant statistical results
head(COchar_clin_LR$LR_table_sig[, 1:4], 5)

# view result: matrix of heatmap
head(COchar_clin_LR$LR_reorder_mat[, 1:2])
```

```{r , fig.cap = "The heatmap of linear regression for lipid characteristics analysis. Only the variables that pass the user-defined cut-offs for p-value and the correlation coefficient are shown on the heatmap. The rows of the heatmap are clinical features and the columns are the lipid characteristics."}
# view result: heatmap of linear regression
COchar_clin_LR$LR_table_plot 
```


# Session info {.unnumbered}
```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {.unnumbered}

