---
title: "Case - two-group data"
output: rmarkdown::html_vignette
bibliography: ref.bib  
description: >
  "LipidSigR" is an R package developed based on LipidSig web-based tool 
   (https://lipidsig.bioinfomics.org/). This package integrates a 
   comprehensive analysis for streamlined data mining of lipidomic datasets. 
   We provide 6 main analysis workflows, which is "Profiling", "Differential 
   expression", "Enrichment", "Machine learning", and "Correlation". 
vignette: >
  %\VignetteIndexEntry{Case - two-group data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r load_package_case two, message = FALSE, echo=FALSE}
library(dplyr)
library(utils)
library(SHAPforxgboost)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
knitr::opts_chunk$set(warning=FALSE)
knitr::opts_chunk$set(fig.width = 6, fig.height = 5)
```


# Introduction
This documentation will show the complete procedure for analyzing two-group data. 
For profiling, differential expression, enrichment, and network analysis, we use 
data from the study "Adipose tissue ATGL modifies the cardiac lipidome in 
pressure-overload-induced left ventricular failure" [@salatzki2018adipose] 
as an example. For machine learning, we use data from the study "The landscape 
of cancer cell line metabolism" [@li2019landscape] due to the sample size limitations.  


# Installation 
Here is the procedures of running the **LipidSigR** package on your system. 
We assume that you have already installed the R program (see the R project at 
[http://www.r-project.org](http://www.r-project.org)  and are familiar with it. 
You need to have R 4.3.0 or a later version installed for running LipidSigR.

Our package is available at the github 
[https://github.com/BioinfOMICS/LipidSigR](https://github.com/BioinfOMICS/LipidSigR). 
Following are the instructions for installing our package.

```{r install package method 1, eval=FALSE}
# Step 1: Install devtools
install.packages("devtools")
```
```{r, eval=FALSE}
# Step 2: Install BiocManager
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
```
```{r , eval=FALSE}
# Step 3: Install LipidSigR
## Update repositories
options(repos = c(
    CRAN = "https://cloud.r-project.org/",
    BiocManager::repositories()))

## Install dependencies and package
devtools::install_github(
    "BioinfOMICS/LipidSigR", 
    build_vignettes = TRUE, dependencies = TRUE)
```

LipidSigR relies on several dependencies. If an error indicates a missing package, 
you can install the required packages using the commands below.
```{r eval=FALSE}
# LipidSigR package depends on several packages, which can be installed using the below commands:
BiocManager::install(
    c('fgsea', 'gatom', 'mixOmics', 'S4Vectors', 'BiocGenerics', 
      'SummarizedExperiment', 'rgoslin'))

install.packages(
    c('devtools', 'magrittr', 'plotly', 'tidyverse', 'factoextra', 'ggthemes', 
      'ggforce', 'Hmisc', 'heatmaply', 'hwordcloud', 'iheatmapr', 'Rtsne', 'uwot', 
      'wordcloud', 'rsample', 'ranger', 'caret', 'yardstick', 'fastshap', 
      'SHAPforxgboost', 'visNetwork', 'tidygraph', 'ggraph'))

devtools::install_github("ctlab/mwcsr")
```

After the installation, you can load and start using our package!
```{r load LipidSigR, message = FALSE}
library(LipidSigR)
```

# Data preparation
The input data of our functions must be a SummarizedExperiment object construct 
by `as_summarized_experiment` or output from upstream analysis function. 

## Input data for general analysis
For profiling, differential expression, enrichment, and network analysis, we use 
data from the study "Adipose tissue ATGL modifies the cardiac lipidome in 
pressure-overload-induced left ventricular failure" [@salatzki2018adipose] as an 
example dataset. The human plasma lipidome of 10 healthy controls and 13 patients 
with systolic heart failure (HFrEF) was analyzed using MS-based shotgun lipidomics. 
Through the steps below, you can construct the input SummarizedExperiment object. 
*NOTE: For constructing the input data for machine learning analysis and correlation analysis, please refer to the corresponding section ([Input data for machine learning](#data-ml) and [Input data for correlation](#data-corr)).* 

### Input data frames
The abundance data and group information table must be provided as data 
frames and adhere to the following requirements.

**Abundance data**: The lipid abundance data includes the abundance values 
of each feature across all samples. 

1. The first column of abundance data must contain a list of lipid names (features). 
2. Each lipid name (feature) is unique.
3. All abundance values are numeric.

For example:
```{r abundance_twoGroup}
rm(list = ls())
data("abundance_twoGroup")
head(abundance_twoGroup[, 1:6], 5)
```

**Group information table**: The group information table contains the grouping 
details corresponding to the samples in lipid abundance data.

1. The column names are arranged in order of sample_name, label_name, group, and pair.
2. All sample names are unique.
3. Sample names in 'sample_name' column are as same as the sample names in lipid abundance data.
4. Columns of 'sample_name', 'label_name', and 'group' columns do not contain NA values.
5. The column 'group' contain 2 groups.
6. In the 'pair' column for paired data, each pair must be sequentially numbered 
from 1 to N, ensuring no missing, blank, or skipped numbers are missing; 
otherwise, the value should be all marked as NA.

For example:
```{r groupInfo_twoGroup}
data("group_info_twoGroup")
head(group_info_twoGroup, 5)
```

### Mapping lipid characteristics
The purpose of this step is to exclude lipid features not recognized 
by `rgoslin` package. Please follow the instructions below before 
constructing the input data as a SummarizedExperiment object.

* In this step, an error message will be returned if `rgoslin::parseLipidNames` cannot 
recognize a certain lipid. However, if your data contains at least two recognizable lipids, 
it will be sufficient for analysis *(note that different analyses may have varying data requirements)*.

```{r rgoslin_twoGroup}
library(dplyr)
# map lipid characteristics by rgoslin
parse_lipid <- rgoslin::parseLipidNames(lipidNames=abundance_twoGroup$feature)

# filter lipid recognized by rgoslin
recognized_lipid <- parse_lipid$Original.Name[
    which(parse_lipid$Grammar != 'NOT_PARSEABLE')]
abundance <- abundance_twoGroup %>%
    dplyr::filter(feature %in% recognized_lipid)
goslin_annotation <- parse_lipid %>%
    dplyr::filter(Original.Name %in% recognized_lipid)
```
After running the above code, two data frames, `abundance`, and 
`goslin_annotation`, will be generated and used in the next step.
```{r rgoslin_output}
head(abundance[, 1:6], 5)
head(goslin_annotation[, 1:6], 5)
```

### Construct SE object
```{r as_summarized_experiment}
se <- as_summarized_experiment(
    abundance, goslin_annotation, group_info=group_info_twoGroup, 
    se_type='de_two', paired_sample=FALSE)
```
After running the above code, you are ready to begin the analysis with the 
output `se`. After the code execution, a summary of the input data will be 
displayed. 

*(Note: If errors occur during execution, please revise the input data to resolve them.)*

Four main analysis workflows—"Profiling," "Differential Expression," "Enrichment," 
and "Network"—can be conducted for two-group data.

* [**"Profiling"**](#profiling) provides an overview of comprehensive analyses to efficiently 
examine data quality, the clustering of samples, the correlation between 
lipid species, and the composition of lipid characteristics. 

* [**"Differential expression"**](#de) integrates many useful lipid-focused analyses for 
identifying significant lipid species or lipid characteristics. 

* [**"Enrichment"**](#enrich) provides two main approaches: 'Over Representation Analysis (ORA)' 
and 'Lipid Set Enrichment Analysis (LSEA)' to illustrates significant lipid species 
enriched in the categories of lipid class and determine whether an a priori-defined set of 
lipids shows statistically significant, concordant differences between two 
biological states (e.g., phenotypes). 

* [**"Network"**](#net) provides functions for generates input table for constructing 
pathway activity network, lipid reaction network and GATOM network.

Please refer to the corresponding section for detailed descriptions and instructions.

## Input data for machine learning {#data-ml}
The data must include at least 60 samples for machine learning analysis, and the 
group information table format differs from other analyses. For these reasons, we 
use data from the study "The landscape of cancer cell line metabolism" here, where 
cancer cell lines are evenly divided into groups sensitive or resistant to SCD 
gene knockout based on gene dependency scores (CERES) [@li2019landscape]. This 
dataset consists of Group 0 (N = 114) and Group 1 (N = 114).

The input data of our functions must be a SummarizedExperiment object construct 
by `LipidSigR::as_summarized_experiment` and after being processed by `LipidSigR::data_process`.

### Input data frames
The abundance data and group information table must be provided as data 
frames and adhere to the following requirements.

**Abundance data**: The lipid abundance data includes the abundance values 
of each feature across all samples. 

1. The first column of abundance data must contain a list of lipid names (features). 
2. Each lipid name (feature) is unique.
3. All abundance values are numeric.

For example:
```{r abundance_ml}
data("ml_abundance")
head(ml_abundance[, 1:6], 5)
```

**Group information table**: The group information table contains the grouping 
details corresponding to the samples in lipid abundance data.

1. The column names must be arranged in order of 'sample_name' and 'group'.
2. Sample names 'sample_name' column must be as same as the sample names in lipid abundance data.
3. The column 'group' must be numeric (only be 0 or 1).
4. Each group must have more than 30 samples.

For example:
```{r groupInfo_ml}
data("condition_table")
head(condition_table, 5)
```

### Mapping lipid characteristics
The purpose of this step is to exclude lipid features not recognized 
by `rgoslin` package. Please follow the instructions below before 
constructing the input data as a SummarizedExperiment object.

* In this step, an error message will be returned if `rgoslin::parseLipidNames` cannot 
recognize a certain lipid. However, if your data contains at least two recognizable lipids, 
it will be sufficient for analysis *(note that different analyses may have varying data requirements)*.

```{r rgoslin__ml}
library(dplyr)
# map lipid characteristics by rgoslin
parse_lipid <- rgoslin::parseLipidNames(lipidNames=ml_abundance$feature)

# filter lipid recognized by rgoslin
recognized_lipid <- parse_lipid$Original.Name[
    which(parse_lipid$Grammar != 'NOT_PARSEABLE')]
abundance <- ml_abundance %>% 
    dplyr::filter(feature %in% recognized_lipid)
goslin_annotation <- parse_lipid %>% 
    dplyr::filter(Original.Name %in% recognized_lipid)
```
After running the above code, two data frames, `abundance`, and 
`goslin_annotation`, will be generated and used in the next step.
```{r rgoslin_output_ml}
head(abundance[, 1:6], 5)
head(goslin_annotation[, 1:6], 5)
```

### Construct SE object
```{r as_summarized_experiment_ml}
ml_input <- as_summarized_experiment(
    abundance, goslin_annotation, group_info=condition_table, 
    se_type='ml', paired_sample=NULL)
```
After running the above code, you are ready to begin the analysis with the 
output `se`. After the code execution, a summary of the input data will be 
displayed. 

*(Note: If errors occur during execution, please revise the input data to resolve them.)*

## Input data for correlation {#data-corr}
In the correlation workflow, we use data from the study "Plasma sphingolipids 
associated with chronic obstructive pulmonary disease phenotypes", which identified 
strong associations between sphingomyelins and emphysema and between 
glycosphingolipids and COPD exacerbations [@bowler2015plasma].

This dataset consists of 129 samples.

The input data of our functions must be a SummarizedExperiment object construct 
by `LipidSigR::as_summarized_experiment` and after being processed by `LipidSigR::data_process`.

### Input data frames
The abundance data and group information table must be provided as data 
frames and adhere to the following requirements.

**Abundance data**: The lipid abundance data includes the abundance values 
of each feature across all samples. 

1. The first column of abundance data must contain a list of lipid names (features). 
2. Each lipid name (feature) is unique.
3. All abundance values are numeric.

For example:
```{r abundance_corr}
data("corr_abundance")
head(corr_abundance[, 1:6], 5)
```

**Group information table**: The group information table includes various clinical 
attributes, including age, sex, BMI, clinical sub-phenotypes of COPD, symptoms, etc.

1. The first column name must be 'sample_name'.
2. Sample names 'sample_name' column must be as same as the sample names in lipid abundance data.
3. The column 'sample_name' must contain character values.
4. Must include at least two columns containing numeric values (except 'sample_name' column).

For example:
```{r groupInfo_corr}
data("corr_group_info")
head(corr_group_info[, 1:6], 5)
```

### Mapping lipid characteristics
The purpose of this step is to exclude lipid features not recognized 
by `rgoslin` package. Please follow the instructions below before 
constructing the input data as a SummarizedExperiment object.

* In this step, an error message will be returned if `rgoslin::parseLipidNames` cannot 
recognize a certain lipid. However, if your data contains at least two recognizable lipids, 
it will be sufficient for analysis *(note that different analyses may have varying data requirements)*.

```{r rgoslin_corr}
library(dplyr)
# map lipid characteristics by rgoslin
parse_lipid <- rgoslin::parseLipidNames(lipidNames=corr_abundance$feature)

# filter lipid recognized by rgoslin
recognized_lipid <- parse_lipid$Original.Name[
    which(parse_lipid$Grammar != 'NOT_PARSEABLE')]
abundance <- corr_abundance %>% 
    dplyr::filter(feature %in% recognized_lipid)
goslin_annotation <- parse_lipid %>% 
    dplyr::filter(Original.Name %in% recognized_lipid)
```
After running the above code, two data frames, `abundance`, and 
`goslin_annotation`, will be generated and used in the next step.
```{r rgoslin_output_corr}
head(abundance[, 1:6], 5)
head(goslin_annotation[, 1:6], 5)
```

### Construct SE object
```{r as_summarized_experiment_corr}
corr_input <- as_summarized_experiment(
    abundance, goslin_annotation, group_info=corr_group_info, 
    se_type='corr', paired_sample=NULL)
```
After running the above code, you are ready to begin the analysis with the 
output `se`. After the code execution, a summary of the input data will be 
displayed. 

*(Note: If errors occur during execution, please revise the input data to resolve them.)*


# Profiling {#profiling}
The first step in analyzing lipid data is to take an overview of the data. 
In this section, you can get comprehensive analyses to explore the quality and 
clustering of samples, the correlation between lipids and samples, and 
the abundance and composition of lipids.

## Cross-sample variability
Now, let's start with a simple view of sample variability to compare the 
amount/abundance difference of lipid between samples (i.e., patients vs. control).
We will use the `se` conducted in the previous section as the input data.

```{r Profiling: cross-sample variability}
# conduct profiling
result <- cross_sample_variability(se)

# result summary
summary(result)
```
After running the above code, you will obtain a list called `result`, containing 
interactive plots, static plots, and tables for three types of distribution plots.
*(Note: Only static plots are displayed here.)*
```{r , fig.width=8}
# view result: histogram of lipid numbers
result$static_lipid_number_barPlot
```

**Histogram of lipid numbers** 
The histogram overviews the total number of lipid species over samples. 
From the plot, we can discover the number of lipid species present in each sample.


```{r , fig.width=8.2}
# view result: histogram of the total amount of lipid in each sample.
result$static_lipid_amount_barPlot  
```

**Histogram of lipid amount**
The histogram describes the variability of the total lipid amount between samples.


```{r , fig.width=7.7}
# view result: density plot of the underlying probability distribution
result$static_lipid_distribution
```

**Density plot of abundance distribution**
The density plot uncovers the distribution of lipid abundance in each sample (line). 
From this plot, we can have a deeper view of the distribution between samples.


## Dimensionality reduction {#pro-dr}
Dimensionality reduction is commonly used when dealing with large numbers of 
observations and/or large numbers of variables in lipids analysis. It transforms 
data from a high-dimensional space into a low-dimensional space so that it 
retains vital properties of the original data and is close to its intrinsic dimension.

Here we provide 3 dimensionality reduction methods, PCA, t-SNE, UMAP. 
As for the number of groups shown on the PCA, t-SNE, and UMAP plot, 
it can be defined by users (default: 2 groups). 

###  PCA {#pca}
PCA (Principal component analysis) is an unsupervised linear dimensionality 
reduction and data visualization technique for high dimensional data, which tries 
to preserve the global structure of the data. Scaling (by default) indicates that 
the variables should be scaled to have unit variance before the analysis takes 
place, which removes the bias towards high variances. In general, scaling 
(standardization) is advisable for data transformation when the variables in the 
original dataset have been measured on a significantly different scale. As for 
the centering options (by default), we offer the option of mean-centering, 
subtracting the mean of each variable from the values, making the mean of each 
variable equal to zero. It can help users to avoid the interference of misleading 
information given by the overall mean.
```{r Profiling: dimensionality reduction - PCA}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')
# conduct PCA
result_pca <- dr_pca(
    processed_se, scaling=TRUE, centering=TRUE, clustering='kmeans', 
    cluster_num=2, kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, 
    eps=NULL, minPts=NULL, feature_contrib_pc=c(1,2), plot_topN=10)

# result summary
summary(result_pca)
```
After running the above code, you will obtain a list containing interactive plots, 
static plots, and tables for three types of distribution plots.
*(Note: Only static plots are displayed here.)*

```{r }
# view result: PCA plot
result_pca$static_pca
```

**PCA plot**

```{r}
# view result: scree plot of top 10 principle components
result_pca$static_screePlot
```

**Scree plot**
A common method for determining the number of PCs to be retained. The 'elbow' of the graph indicates all components to the left of this point can explain most variability of the samples

```{r}
# view result: correlation circle plot of PCA variables
result_pca$static_feature_contribution
```

**Correlation circle plot**
The correlation circle plot showing the correlation between a feature (lipid species) and a principal component (PC) used as the coordinates of the variable on the PC [@abdi2010principal]. The positively correlated variables are in the same quadrants while negatively correlated variables are on the opposite sides of the plot origin. The closer a variable to the edge of the circle, the better it represents on the factor map.


```{r}
# view result: bar plot of contribution of top 10 features
result_pca$static_variablePlot
```

**Bar plot of contribution of top 10 features**
The plot displaysthe features (lipid species) that contribute more to the user-defined principal component.


### t-SNE  {#tsne}
t-SNE (t-Distributed Stochastic Neighbour Embedding) is an unsupervised 
non-linear dimensionality reduction technique that tries to retain the local 
structure(cluster) of data when visualising the high-dimensional datasets. 
Package `Rtsne` is used for calculation, and PCA is applied as a 
pre-processing step. In t-SNE, `perplexity` and `max_iter` are adjustable for 
users. The `perplexity` may be considered as a knob that sets the number of 
effective nearest neighbours, while `max_iter` is the maximum number of iterations 
to perform. The typical perplexity range between 5 and 50, but if the t-SNE 
plot shows a ‘ball’ with uniformly distributed points, you may need to lower 
your perplexity [@van2008visualizing].

```{r Profiling: dimensionality reduction - t-SNE}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')
# conduct t-SNE
result_tsne <- dr_tsne(
    processed_se, pca=TRUE, perplexity=5, max_iter=500, clustering='kmeans',
    cluster_num=2, kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, 
    eps=NULL, minPts=NULL)

# result summary
summary(result_tsne)
```

```{r }
# view result: t-SNE plot
result_tsne$static_tsne
```

**t-SNE plot**


###  UMAP  {#umap}
UMAP (Uniform Manifold Approximation and Projection) using a nonlinear 
dimensionality reduction method, Manifold learning, which effectively visualizing 
clusters or groups of data points and their relative proximities. Both tSNE and 
UMAP are intended to predominantly preserve the local structure that is to group 
neighbouring data points which certainly delivers a very informative visualization 
of heterogeneity in the data. The significant difference with t-SNE is scalability, 
which allows UMAP eliminating the need for applying pre-processing step (such as PCA). 
Besides, UMAP applies Graph Laplacian for its initialization as tSNE by default 
implements random initialization. Thus, some people suggest that the key problem 
of tSNE is the Kullback-Leibler (KL) divergence, which makes UMAP superior over 
t-SNE. Nevertheless, UMAP’s cluster may not good enough for multi-class pattern 
classification [@mcinnes2018umap].
    
The type of distance metric to find nearest neighbors the size of the local 
neighborhood (as for the number of neighboring sample points) are set by 
parameter `metric` and `n_neighbors`. Larger values lead to more global views 
of the manifold, while smaller values result in more local data being preserved. 
Generally,  values are set in the range of 2 to 100. (default: 15).

```{r Profiling: dimensionality reduction - UMAP}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')
# conduct UMAP
result_umap <- dr_umap(
    processed_se, n_neighbors=15, scaling=TRUE, umap_metric='euclidean',
    clustering='kmeans', cluster_num=2, kmedoids_metric=NULL,
    distfun=NULL, hclustfun=NULL, eps=NULL, minPts=NULL)

# result summary
summary(result_umap)
```

```{r }
# view result: UMAP plot
result_umap$static_umap
```

**UMAP plot**

## Correlation heatmap
The correlation heatmap illustrates the correlation between samples or lipid
species and also depicts the patterns in each group. The correlation is
calculated by the method defined by parameter `corr_method`, and the
correlation coefficient is then clustered depending on method defined by
parameter `distfun` and the distance defined by parameter
`hclustfun`. Users can choose to output the sample correlation or lipid correlation 
results by the parameter `type`.

Please note that if the number of lipids or samples is over 50, the names of
lipids/samples will not be shown on the heatmap.

Here, we use `type='sample'` as example. 
```{r Profiling: correlation heatmap}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')
# correlation calculation
result_heatmap <- heatmap_correlation(
    processed_se, char=NULL, transform='log10', correlation='pearson', 
    distfun='maximum', hclustfun='average', type='sample')
# result summary          
summary(result_heatmap)
```

```{r }
# view result: sample-sample heatmap
result_heatmap$static_heatmap
```

**Heatmap of sample to sample correlations**
Correlations between lipid species are colored from strong positive correlations (red) to no correlation (white).

## Lipid characteristics
Now, we are going to take a view of lipid expression over specific lipid
characteristics. First, lipids are classified by characteristics selected from
the 'Lipid characteristics' table. Here, we select "class" as the selected lipid
characteristic. The results will be showed by two plots.
```{r Profiling: lipid characteristics}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')

# list lipid characteristics
list_lipid_char(processed_se)$common_list

# calculate lipid expression of selected characteristic
result_lipid <- lipid_profiling(processed_se, char="class")

# result summary
summary(result_lipid)
```

```{r , fig.width=8}
# view result: bar plot
result_lipid$static_char_barPlot
```

**Bar plot classified by selected characteristic**
The bar plot depicts the abundance level of each sample within each group (e.g., PE, PC) of selected characteristics (e.g., class).
 
```{r , fig.width=8}
# view result: stacked horizontal bar chart
result_lipid$static_lipid_composition    
```

**Lipid class composition**
The stacked horizontal bar chart illustrates the percentage of characteristics 
in each sample. The variability of percentage between samples can also be obtained from this plot.

# Differential expression {#de}
After overviewing the lipid data, then we move on to differential expression to
identify the significant lipid species and lipid characteristics. Differential
Expression is divided into two main analyses, **'Lipid species analysis'**
and **'Lipid characteristics analysis'**. Further analysis and
visualization methods can also be conducted based on the results of differential
expressed analysis.

* **Lipid species analysis**: The lipid species analysis explores the
  significant lipid species based on differentially expressed analysis. Data are
  analyzed based on each lipid species. Further analysis and visualization
  methods, include

  1. dimensionality reduction,
  2. hierarchical clustering,
  3. characteristics association.

* **Lipid characteristics analysis**: The lipid characteristics
  analysis explores the significant lipid characteristics. Lipid species are
  categorized and summarized into a new lipid abundance table according to a
  selected lipid characteristic. The abundance of all lipid species of the same
  categories are summed up, then conduct differential expressed analysis.
  Further analysis and visualization methods include

  1. dimensionality reduction, 
  2. hierarchical clustering, 
  3. double bond-chain length analysis.
  
## Lipid species analysis
Now, let's start with the analysis of lipid species.

### Differential expression analysis {#desp}
For lipid species analysis section, differential expression analysis is
performed to figure out significant lipid species. In short, samples will be
divided into two groups (independent) according to the input "Group
Information" table.
```{r DE_lipid species: differentially expressed analysis}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')

# conduct differential expression analysis of lipid species
deSp_se <- deSp_twoGroup(
    processed_se, ref_group='ctrl', test='t-test',
    significant='pval', p_cutoff=0.05, FC_cutoff=1, transform='log10')
```

After running the above code, a SummarizedExperiment object `deSp_se` will be 
returned containing the analysis results. This object can be used as input for 
plotting and further analyses such as [dimensionality reduction](#desp-dr), 
[hierarchical clustering](#desp-clustering), 
[characteristics association](#desp-char), [enrichment analysis](#enrich), 
and [network analysis](#net).

`deSp_se` includes the input abundance data, lipid characteristic table, 
group information table, analysis results, and some some setting of input parameters. 
You can view the data in `deSp_se` by `LipidSigR::extract_summarized_experiment`.
```{r DE_lipid species: differentially expressed analysis data}
# view differential expression analysis of lipid species
deSp_result <- extract_summarized_experiment(deSp_se)

# result summary
summary(deSp_result)
```

The differential expression analysis result can be input for plotting MA plots, 
volcano plots, and lollipop plots. *(Note: Only static plots are displayed here.)*
```{r}
# plot differential expression analysis result
deSp_plot <- plot_deSp_twoGroup(deSp_se)

# result summary
summary(deSp_plot)
```

```{r}
# view result: lollipop chart
deSp_plot$static_de_lipid
```

**Lollipop chart of lipid species analysis**
The lollipop chart reveals the lipid species that pass chosen cut-offs. The x-axis shows log2 fold change while the y-axis is a list of lipids species. The color of the point is determined by `-log10(adj_value/p-value)`.

```{r }
# view result: MA plot
deSp_plot$static_maPlot
```

**MA plot**
The MA plot indicates three groups of lipid species, up-regulated(red), down-regulated(blue), and non-significant(grey).
 
```{r}
# view result: volcano plot
deSp_plot$static_volcanoPlot 
```

**Volcano plot**
The volcano plot illustrates a similar concept to the MA plot. These points visually identify the most biologically significant lipid species (red for up-regulated, blue for down-regulated, and grey for non-significant).

You can further plot an abundance box plot for any lipid species of interest by 
`LipidSigR::boxPlot_feature_twoGroup`. 

For example, let's use `TAG 48:0;0`, a significant lipid species from the lollipop above.
```{r boxPlot}
# plot abundance box plot of 'TAG 48:0;0'
boxPlot_result <- boxPlot_feature_twoGroup(
    processed_se, feature='TAG 48:0;0', ref_group='ctrl', test='t-test',
    transform='log10')
# result summary
summary(boxPlot_result)

# view result: static box plot
boxPlot_result$static_boxPlot
```

**Box plot of lipid abundance** An asterisk sign indicates significant differences between groups. 
The absence of an asterisk or line denotes a non-significant difference between groups.


### Dimension reduction {#desp-dr}
Dimension reduction is common when dealing with large numbers of
observations and/or large numbers of variables in lipids analysis. It transforms
data from a high-dimensional space into a low-dimensional space to retain vital
properties of the original data and close to its intrinsic dimension.

Here, we provide four dimension reduction methods: in addition to the previously 
introduced PCA, t-SNE, and UMAP 
(details in Section [PCA](#pca), [t-SNE](#tsne), [UMAP](#umap)), we include PLS-DA.

* Note: The input data of this section is the output data of `LipidSigR::deSp_twoGroup`.

#### PCA, t-SNE, UMAP
Previous sections introduced details of PCA (Principal Component Analysis), 
t-SNE (t-distributed stochastic neighbor embedding), and UMAP (Uniform Manifold Approximation and Projection) 
(please refer to Section [PCA](#pca), [t-SNE](#tsne), [UMAP](#umap)). 

The only difference in running the functions is that the input data changes from 
`processed_se` to `deSp_se` (output from [lipid species analysis](#desp)). 

Here, we use PCA as an example.
```{r DE_lipid species: dimensionality reduction - PCA}
# conduct PCA
result_pca <- dr_pca(
    deSp_se, scaling=TRUE, centering=TRUE, clustering='kmeans', 
    cluster_num=2, kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, 
    eps=NULL, minPts=NULL, feature_contrib_pc=c(1,2), plot_topN=10)

# result summary
summary(result_pca)
```

#### PLS-DA {#plsda}
The input data is the output data of `deSp_twoGroup` from [lipid species analysis](#desp).
```{r DE_lipid species: dimensionality reduction - PLS-DA}
# conduct PLSDA
result_plsda <- dr_plsda(
  deSp_se, ncomp=2, scaling=TRUE, clustering='group_info', cluster_num=2, 
  kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, eps=NULL, minPts=NULL)

# result summary
summary(result_plsda)
```

```{r }
# view result: PLS-DA plot
result_plsda$static_plsda
```

**PLS-DA plot**

```{r}
# view result: PLS-DA loading plot
result_plsda$static_loadingPlot    
```

**Loading plot**
In the PLS-DA loading plot, the distance to the center of the variables indicates the contribution of the variable. The value of the x-axis reveals the contribution of the variable to PLS-DA-1, whereas the value of the y-axis discloses the contribution of the variable to PLS-DA-2.

### Hierarchical clustering {#desp-clustering}
Based on the results of differential expression analysis, we further take a
look at differences of lipid species between the control group and the
experimental group. Lipid species derived from two groups are clustered and
visualized on heatmap by hierarchical clustering. Users can choose to output the
results of all lipid species or only significant lipid species by the parameter `type`.
    
The top of the heatmap is grouped by sample group (top annotation) while the side 
of the heatmap (row annotation) can be chosen from `lipid_char_table`, such as class, 
structural category, functional category, total length, total double bond (Total.DB), 
hydroxyl group number (Total.OH), the double bond of fatty acid(FA.DB), 
hydroxyl group number of fatty acid(FA.OH).

```{r DE_lipid species: hierarchical clustering}
# list available lipid characteristics
list_lipid_char(processed_se)$common_list

# conduct hierarchical clustering
result_hcluster <- heatmap_clustering(
    de_se=deSp_se, char='class', distfun='pearson', 
    hclustfun='complete', type='sig')

# result summary
summary(result_hcluster)
```

```{r}
# view result: heatmap of significant lipid species
result_hcluster$static_heatmap
```

**Heatmap of significant lipid species**
The difference between the two groups by observing the distribution of lipid species.

### Characteristics analysis {#desp-char}
The characteristics analysis visualizes the difference between control and 
experimental groups of significant lipid species categorized based on different 
lipid characteristics from `lipid_char_table`, such as class, 
structural category, functional category, total length, total double bond (Total.DB), 
hydroxyl group number (Total.OH), the double bond of fatty acid(FA.DB), 
hydroxyl group number of fatty acid(FA.OH).
```{r DE_lipid species: characteristics analysis}
# list available lipid characteristics
list_lipid_char(processed_se)$common_list

# conduct characteristic analysis
result_char <- char_association(deSp_se, char='class')

# result summary
summary(result_char)
```

```{r }
# view result: bar chart
result_char$static_barPlot
```

**The bar chart of significant groups**
The bar chart shows the significant groups (values) with mean fold change over 2 in the selected characteristics by colors (red for significant and black for insignificant).

```{r }
# view result: lollipop plot
result_char$static_lollipop
```

**The lollipop chart of all significant groups**
The lollipop chart compares multiple values simultaneously and it aligns the log2(fold change) of all significant groups (values) within the selected characteristics.

```{r , fig.small=TRUE, fig.width=3, fig.height=3}
# view result: word cloud 
result_char$static_wordCloud
```

**Word cloud with the count of each group**
The word cloud shows the count of each group(value) of the selected characteristics.


## Lipid characteristics analysis
After lipid species analysis, now let's move on to another main analysis of the
Differential expression section -- **'Lipid Characteristics Analysis'**.
The massive degree of structural diversity of lipids contributes to the
functional variety of lipids. The characteristics can range from subtle
variance (i.e. the number of a double bond in the fatty acid) to major change
(i.e. diverse backbones). In this section, lipid species are categorized and
summarized into a new lipid abundance table according to two selected lipid
characteristics, then conducted differential expressed analysis. Samples are
divided into two groups based on the input 'Group Information' table.

### Differentially expressed analysis {#dechar}
In differentially expressed analysis, we are going to conduct two procedures of 
analysis - first is **'Characteristics'** and then **'Subgroup of characteristics'**. 

**'Characteristics'** is based on the first selected 'characteristics' 
while **'Subgroup of characteristics'** is the subgroup analysis of the previous section. 
Analyses will be performed based on parameter `char` and `subChar` selected by users.

Before we begin, let's calculate the two-way ANOVA and review the results for all lipid characteristics.
```{r two_way_anova}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')

# two way anova
twoWayAnova_table <- char_2wayAnova(
  processed_se, ratio_transform='log2', char_transform='log10')

# view result table
head(twoWayAnova_table[, 1:4], 5) 
```

From the table returned by `LipidSigR::char_2wayAnova`, we have to selected the 
lipid characteristics of interest as `char` and `subChar` 
for `LipidSigR::deChar_twoGroup` and `LipidSigR::subChar_twoGroup`. 

Here, we use `Total.C` as an example.
```{r DE_lipid characteristics: differentially expressed analysis}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')

# conduct differential expression of lipid characteristics
deChar_se <- deChar_twoGroup(
    processed_se, char="Total.C", ref_group="ctrl", test='t-test', 
    significant="pval", p_cutoff=0.05, FC_cutoff=1, transform='log10')
```

After running the above code, a SummarizedExperiment object `deChar_se` will be 
returned containing the analysis results. This object can be used as input for 
plotting and further analyses such as [dimension reduction](#dechar-dr), and
[hierarchical clustering](dechar-clustering).

`deChar_se` includes the input abundance data, lipid characteristic table, 
group information table, analysis results, and some some setting of input parameters. 
You can view the data in `deChar_se` by `LipidSigR::extract_summarized_experiment`.
```{r DE_lipid characteristics: differentially expressed analysis data}
# view differential expression of lipid characteristics
deChar_result <- extract_summarized_experiment(deChar_se)

# result summary
summary(deChar_result)
```

The differential expression analysis result can be input for plotting result plots. 
*(Note: Only static plots are displayed here.)*

```{r }
# plot differential expression analysis results
deChar_plot <- plot_deChar_twoGroup(deChar_se)

# result summary
summary(deChar_plot)
```

**The results of 'Characteristics' analysis in the first section**

```{r }
# view result: bar plot of selected `char`
deChar_plot$static_barPlot

# view result: sqrt-scaled bar plot of selected `char`
deChar_plot$static_barPlot_sqrt

# view result: line plot of `selected char`
deChar_plot$static_linePlot

# view result: sqrt-scaled line plot of selected `char`
deChar_plot$static_linePlot_sqrt  

# view result: box plot of selected `char`
deChar_plot$static_boxPlot  
```

In the **'Subgroup of characteristics'**, besides the selected characteristic in 
first section defined by parameter `char`, we can further choose another 
characteristic by parameter `subChar`. The two chosen characteristics, 
`char` and `subChar`should be either both continuous data or one continuous and 
one categorical data.

* NOTE: You can use `LipidSigR::list_lipid_char` to get all the selectable lipid characteristics. 
Please read `vignette("tool_function")`.

```{r DE_lipid characteristics: differentially expressed analysis_Subgroup}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')

# subgroup differential expression of lipid characteristics
subChar_se <- subChar_twoGroup(
    processed_se, char="Total.C", subChar="class", ref_group="ctrl", 
    test='t-test', significant="pval", p_cutoff=0.05, 
    FC_cutoff=1, transform='log10')
```

After running the code, the returned `subChar_se` contained the input abundance 
data, lipid characteristic table, group information table, analysis results, 
and some some setting of input parameters. 
You can view the data in `subChar_se` by `LipidSigR::extract_summarized_experiment`.
```{r }
# view differential expression of lipid characteristics
subChar_result <- extract_summarized_experiment(subChar_se)

# result summary
summary(subChar_result)
```

You can also plot the results of a specific feature within the `subChar`. 
For example, if you select "class" as `subChar`, you can choose "Cer" within the 
'class' feature by parameter `subChar_feature` for plotting result plots. 
*(Note: Only static plots are displayed here.)*
``` {r DE_lipid characteristics: differentially expressed analysis_Subgroup plot}
# get subChar_feature list
subChar_feature_list <- unique(
    extract_summarized_experiment(subChar_se)$all_deChar_result$sub_feature)

# visualize subgroup differential expression of lipid characteristics
subChar_plot <- plot_subChar_twoGroup(subChar_se, subChar_feature="Cer")

# result summary
summary(subChar_plot)
```

**The results of 'Subgroup of characteristics' analysis in the second section**

* *Note: The star above the bar shows the significant difference of the specific subgroup of the selected characteristic between control and experimental groups.*
```{r }
# view result: bar plot of `subChar_feature`
subChar_plot$static_barPlot  

# view result: sqrt-scaled bar plot of `subChar_feature`
subChar_plot$static_barPlot_sqrt 

# view result: line plot of `subChar_feature`
subChar_plot$static_linePlot 

# view result: sqrt-scaled line plot of `subChar_feature`
subChar_plot$static_linePlot_sqrt 

# view result: box plot of `subChar_feature`
subChar_plot$static_boxPlot  
```

### Dimension reduction {#dechar-dr}
Dimension reduction is common when dealing with large numbers of
observations and/or large numbers of variables in lipids analysis. It transforms
data from a high-dimensional space into a low-dimensional space to retain vital
properties of the original data and close to its intrinsic dimension.

Here, we provide 4 dimension reduction methods: PCA, t-SNE, UMAP, and PLS-DA.

The execution of all the functions respectively introduced in Section 
Section [PCA](#pca), [t-SNE](#tsne), [UMAP](#umap), and [PLSDA](#plsda). Links to there for 
more details manipulation.

The only difference is that the input data should be `deChar_se` (output from [lipid characterisitcs analysis](#dechar)).

For example: 
```{r DE_lipid characteristics: dimensionality reduction - PLS-DA}
# conduct PLSDA
result_plsda <- dr_plsda(
  deChar_se, ncomp=2, scaling=TRUE, clustering='group_info', cluster_num=2, 
  kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, eps=NULL, minPts=NULL)

# result summary
summary(result_plsda)
```

### Hierarchical clustering {#dechar-clustering}
Hierarchical clustering can also be conducted based on the differential expression 
analysis results of lipid characteristics. It visualizes the differences of lipid 
characteristics between the control group and the experimental group. 

* *NOTE: The `char` parameter should match the input used in the `deChar_twoGroup` from [lipid characteristics analysis](#dechar)*
```{r DE_lipid characteristics: hierarchical clustering}
# conduct hierarchical clustering
result_hcluster <- heatmap_clustering(
    de_se=deChar_se, char='Total.C', distfun='pearson',
    hclustfun='complete', type='all')

# result summary
summary(result_hcluster)
```

```{r }
# view result: heatmap of significant lipid species
result_hcluster$static_heatmap
```

**Heatmap of significant lipid species**
The difference between the two groups by observing the distribution of lipid species.

### Double bond-chain length analysis  analysis 
This section provides heatmaps that illustrates the correlation between the 
double bond and chain length of lipid species. The color in the heatmaps is 
gradient according to log2FC.

The correlation is visually represented by cell colors—red indicates a 
positive correlation, while blue indicates a negative. 
Significant correlations are highlighted with an asterisk sign on the plot.
```{r DE_lipid characteristics: two-heatmap all, fig.width=7.8}
# data processing
processed_se <- data_process(
    se, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min', replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')

# list lipid characteristics
list_lipid_char(processed_se)$chain_db_list

# conduct double bond-chain length analysis (without setting `char_feature`)
heatmap_all <- heatmap_chain_db(
    processed_se, char='class', char_feature=NULL, ref_group='ctrl', 
    test='t-test', significant='pval', p_cutoff=0.05, 
    FC_cutoff=1, transform='log10')

# result summary 
summary(heatmap_all)
# summary of total chain result
summary(heatmap_all$total_chain)
# view result: heatmap of total chain
heatmap_all$total_chain$static_heatmap
# summary of each chain result
summary(heatmap_all$each_chain)
# view result: heatmap of each chain
heatmap_all$each_chain$static_heatmap
```

```{r DE_lipid characteristics: two-heatmap one}
# conduct double bond-chain length analysis (a specific `char_feature`)
heatmap_one <- heatmap_chain_db(
    processed_se, char='class', char_feature='PC', ref_group='ctrl',
    test='t-test', significant='pval', p_cutoff=0.05, 
    FC_cutoff=1, transform='log10')

# result summary 
summary(heatmap_one)
# summary of total chain result
summary(heatmap_one$total_chain)
# view result: heatmap of total chain
heatmap_one$total_chain$static_heatmap
# summary of each chain result
summary(heatmap_one$each_chain)
# view result: heatmap of each chain
heatmap_one$each_chain$static_heatmap
```

* NOTE: You can view the data in `chain_db_se` by `LipidSigR::extract_summarized_experiment`.

For example:
```{r }
# view data in `chain_db_se`
heatmap_one_total_chain_list <- 
    extract_summarized_experiment(heatmap_one$each_chain$chain_db_se)
# result summary
summary(heatmap_one_total_chain_list)
```

You can further plot an abundance box plot for any lipid species of interest by 
`LipidSigR::boxPlot_feature_twoGroup`. 

For example, let's use `15:0`, a significant lipid species from the heatmap above.
```{r boxPlot_two_heatmap}
# plot abundance box plot of "15:0"
boxPlot_result <- boxPlot_feature_twoGroup(
    heatmap_one$each_chain$chain_db_se, feature='15:0', 
    ref_group='ctrl', test='t-test', transform='log10')

# result summary
summary(boxPlot_result)

# view result: static box plot
boxPlot_result$static_boxPlot
```

**Box plot of lipid abundance** An asterisk sign indicates significant differences between groups. 
The absence of an asterisk or line denotes a non-significant difference between groups.


# Enrichment {#enrich}
Enrichment analysis provides two main approaches: 'Over Representation Analysis (ORA)' 
and 'Lipid Set Enrichment Analysis (LSEA)'. ORA analysis illustrates significant 
lipid species enriched in the categories of lipid class. LSEA analysis is a 
computational method determining whether an a priori-defined set of lipids 
shows statistically significant, concordant differences between two biological 
states (e.g., phenotypes).

## Over Representation Analysis (ORA)
The Over-Representation analysis provides whether significant lipid species are 
enriched in the categories of lipid class. Results are presented in tables and bar plots 
categorizing lipid species into 'up-regulated' or 'down-regulated' groups 
based on log2 fold change.

* NOTE: The input data of this section `deSp_se` is generated by `deSp_twoGroup` in [lipid species analysis](#desp).

```{r Enrichment: ora all, fig.width=12}
# conduct ORA 
ora_all <- enrichment_ora(
    deSp_se, char=NULL, significant='pval', p_cutoff=0.05)
# result summary 
summary(ora_all)
# view result: ORA bar plot
ora_all$static_barPlot 
```

**ORA bar plot of all characteristics**
The bar plot shows the top 10 significant up-regulated and down-regulated terms.


```{r Enrichment: ora one}
# list available lipid characteristics
list_lipid_char(processed_se)$common_list

# conduct ORA of a specific `char`
ora_one <- enrichment_ora(
    deSp_se, char='class', significant='pval', p_cutoff=0.05)
# result summary 
summary(ora_one)
# view result: ORA bar plot
ora_one$static_barPlot 
```

**ORA bar plot of specific characteristics**
The bar plot classifies significant lipid species into 'up-regulated' or 'down-regulated' categories based on their log2 fold change, according to a selected characteristic. Red bars indicate up-regulated, blue bars represent down-regulated, and grey bars signify non-significant.


## Lipid Set Enrichment Analysis (LSEA)
Lipid Set Enrichment Analysis (LSEA) is a computational method determining 
whether an a priori-defined set of lipids shows statistically significant, 
concordant differences between two biological states (e.g., phenotypes). 
Results are presented in tables and bar plots categorizing 
lipid species into 'up-regulated' or 'down-regulated' groups based on NES 
(Normalized Enrichment Score), and a table.

* NOTE: The input data of this section `deSp_se` is generated by `deSp_twoGroup` in [lipid species analysis](#desp).

```{r Enrichment: LSEA all, fig.width=12}
# conduct LSEA
lsea_all <- enrichment_lsea(
    deSp_se, char=NULL, rank_by='log2FC', significant='pval', 
    p_cutoff=0.05)

# result summary 
summary(lsea_all)
# view result: LSEA bar plot
lsea_all$static_barPlot
```

**LSEA bar plot of all characteristics**
The bar plot shows the top 10 significant up-regulated and down-regulated terms.


```{r Enrichment: LSEA one}
# list available lipid characteristics
list_lipid_char(processed_se)$common_list

# conduct LSEA of a specific `char`
lsea_one <- enrichment_lsea(
    deSp_se, char='class', rank_by='log2FC', 
    significant='pval', p_cutoff=0.05)
# result summary 
summary(lsea_one)
# view result: LSEA bar plot
lsea_one$static_barPlot
```

**LSEA bar plot of a specific `char`**
The bar plot classifies significant lipid species into 'up-regulated' or 'down-regulated' categories based on their log2 fold change, according to a selected characteristic. Red bars indicate up-regulated, blue bars represent down-regulated, and grey bars signify non-significant.


After running `enrichment_lsea`, you can continue executing `plot_enrichment_lsea` to plot the enrichment plot further.
Please use the whole output of `enrichment_lsea` as the input for plotting.
```{r Enrichment: LSEA one plotting, fig.width=7.8, fig.height=4}
# plot LSEA results
lsea_plot <- plot_enrichment_lsea(
    lsea_res=lsea_one, char='class', char_feature='TG')

# view result: enrichment plot
lsea_plot
```


# Network {#net}
This section provides three functions to quickly generate input data for 
constructing networks. After running the corresponding function, you will
obtain the input data for a specific network. The available networks include the 
Pathway Activity Network, Lipid Reaction Network, and GATOM Network. 
Detailed instructions for each are described in the following sections.

* NOTE: The input data of this section `deSp_se` is generated by `deSp_twoGroup` in [lipid species analysis](#desp).


## Pathway activity network
The network provides activity pathways among lipid classes.

Follow the instructions below to get the input data for constructing the network.
```{r Network: Pathway activity network}
# generate table for constructing Pathway activity network
network_table <- nw_pathway_activity(deSp_se, organism='mouse')

# result summary
summary(network_table)
```

After obtaining all the returned tables, you can use them to construct a 
network. Here, we use the `visNetwork` package to display an example.
```{r }
# network visualization
library(visNetwork)
network <- visNetwork(
    nodes=network_table$table_node, edges=network_table$table_edge) %>%
    visLayout(randomSeed=500) %>%
    visPhysics(
        solver='barnesHut', stabilization=TRUE, 
        barnesHut=list(gravitationalConstant=-3000)) %>%
    visInteraction(navigationButtons=TRUE) %>%
    visEvents(
        dragEnd="function () {this.setOptions( { physics: false } );}") %>%
    visEdges(color=list(color="#DDDDDD",highlight="#C62F4B")) %>%
    visOptions(
        highlightNearest=list(enabled=TRUE, degree=1, hover=FALSE),
        selectedBy="group", nodesIdSelection=TRUE)
# view network
network
```


## Lipid reaction network
This network illustrates the important reactions of differentially expressed lipid classes and species.

Follow the instructions below to get the input data for constructing the network.
```{r Network: Lipid reaction network}
# generate table for constructing Lipid reaction network
network_table <- nw_lipid_reaction(
    deSp_se, organism='mouse', show_sp='sigClass', show_all_reactions=FALSE,
    sp_significant='pval', sp_p_cutoff=0.05, sp_FC_cutoff=1,
    class_significant='pval', class_p_cutoff=0.05, class_FC_cutoff=1)

# result summary
summary(network_table)
```

After obtaining all the returned tables, you can use them to construct a 
network. Here, we use the `visNetwork` package to display an example.
```{r}
library(visNetwork)
# network visualization
network <- visNetwork(
    nodes=network_table$table_node, edges=network_table$table_edge) %>%
    visLayout(randomSeed=500) %>%
    visPhysics(
        solver='barnesHut', stabilization=TRUE, 
        barnesHut=list(gravitationalConstant=-2500)) %>%
    visInteraction(navigationButtons=TRUE) %>%
    visEvents(
        dragEnd="function () {this.setOptions( { physics: false } );}") %>%
    visOptions(
        highlightNearest=list(enabled=TRUE, degree=1, hover=FALSE),
        selectedBy="group", nodesIdSelection=TRUE)
# view network
network
```


## GATOM network
The network shows the important reactions of differentially expressed lipid species.

Follow the instructions below to get the input data for constructing the network.
```{r Network: GATOM network}
# generate table for constructing GATOM network
network_table <- nw_gatom(
    deSp_se, organism='mouse', n_lipid=50, sp_significant='pval',
    sp_p_cutoff=0.05, sp_FC_cutoff=1)

# result summary
summary(network_table)
```

After obtaining all the returned tables, you can use them to construct a 
network. Here, we use the `visNetwork` package to display an example.
```{r}
library(visNetwork)
# network visualization
network <- visNetwork(
    nodes=network_table$table_node, edges=network_table$table_edge) %>%
    visLayout(randomSeed=500) %>%
    visPhysics(
        solver='barnesHut', stabilization=TRUE, 
        barnesHut=list(gravitationalConstant=-3000)) %>%
    visInteraction(navigationButtons=TRUE) %>%
    visEvents(
        dragEnd="function () {this.setOptions( { physics: false } );}") %>%
    visEdges(color=list(color="#DDDDDD",highlight="#C62F4B")) %>%
    visOptions(
        highlightNearest=list(enabled=TRUE, degree=1, hover=FALSE),
        selectedBy="group", nodesIdSelection=TRUE)
# view network
network
```

# Machine learning {#ml}
"Machine learning" provides many feature selection methods and classifiers for 
building binary classification models. Additionally, several following analyses 
help users evaluate algorithm performance and identify key lipid-related variables.

To conduct machine learning analysis, the data must include at least 60 samples, 
and the group information table format differs from the analyses mentioned in the 
previous workflows. Since the example dataset used in previous workflows contains 
only 23 samples, if you want to continue the machine learning analysis, changing 
the example dataset is needed. See the details of input data preparation in 
[Data praparation](#data-ml). This dataset consists of Group 0 (N = 114) and 
Group 1 (N = 114).

## Model construction {#model}
In the machine learning section, we will apply various feature selection methods
and assess each feature's importance. Data on lipid species and lipid characteristics 
will be combined to predict a binary outcome using multiple machine-learning 
approaches, allowing us to identify the optimal feature combination for further analysis. 
Monte Carlo cross-validation (MCCV) will be used to evaluate model performance 
and achieve statistical significance.

Each cross-validation run randomly divides the data into training and testing sets. 
The training data is used to select the top 2, 3, 5, 10, 20, 50, or 100 important 
features for model training. The model is then validated using the testing data. 
If the dataset contains fewer than 100 features, the maximum number of features 
is set to the total available. The proportion of data used for testing and the 
number of cross-validation iterations can be defined by the parameters `split_prop` 
and `nfold`, respectively. 
*(Note: Increasing the number of cross-validation iterations will result in longer computation times.)*

Feature selection methods are designed to identify and rank the most important 
variables for predicting the target outcome. Our platform offers two categories 
of feature selection methods: univariate and multivariate analysis.
In univariate analysis, methods such as p-value, p-value\*Fold Change, and ROC 
are used to compare each feature between two groups. The user can set the criteria 
for ranking the features. Based on users' settings, the top N features are chosen 
using metrics like -log10(p-value), -log10(p-value)\*Fold Change, or the Area 
Under Curve (AUC).
For multivariate analysis, we provide options including Random Forest, Linear 
SVM (`e1071`), Lasso (`glmnet`), Ridge (`glmnet`), and ElasticNet (`glmnet`). 
Random Forest (`ranger`) utilizes built-in feature importance metrics, while the other 
methods rank features based on the absolute values of their coefficients. 
*(Note: The names in parentheses indicate the software packages used.)*

The provided 8 feature ranking methods and 6 classification methods for training 
and selecting the best model are listed below.

    1. Feature ranking methods: p-value, p-value*FC, ROC, Random Forest, Linear SVM, Lasso, Ridge, ElasticNet.
    2. Classification methods: Random Forest, Linear SVM, Lasso, Ridge, ElasticNet, XGBoost.

After constructing the model, a series of consequent analyses can be conducted to 
evaluate the methods and visualize machine learning results, including ROC/PR 
curve, model predictivity, sample probability, feature importance, and network.

Let us begin by building the model. We will use the SummarizedExperiment object 
`ml_input` as the input data. For instructions on constructing the input 
SummarizedExperiment object, please refer to [Data preparation](#data-ml).

```{r ML_model}
# data processing
processed_ml <- data_process(
    ml_input, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min',  replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')

# lipid characteristic
char_list <- list_lipid_char(processed_ml)

# construct machine learning model
ml_se <- ml_model(
    processed_ml, char=c("class","Total.DB"), transform='log10',
    ranking_method='Random_forest', ml_method='Random_forest', 
    split_prop=0.3, nfold=10, alpha=NULL)
```

After running the above code, a SummarizedExperiment object `ml_se` will be 
returned. It includes the input abundance data, lipid characteristic table, 
group information table, analysis results, and input parameter settings. 
You can view the data in `ml_se` by `LipidSigR::extract_summarized_experiment`.

```{r ml analysis: results}
# view machine learning analysis
ml_model_result <- extract_summarized_experiment(ml_se)

# result summary
summary(ml_model_result)
```

`ml_se` can also be used as input for plotting and further analyses such 
as [ROC/PR curve](#rocpr), [model performance](#eval), [predicted probability](#prob), 
[feature importance](#feaimp), and [network analysis](#network). Below is a brief 
introduction to these functions; detailed instructions for usage will be provided 
in the following sections.

* [**"ROC/PR curve"**](#rocpr) provides overall ROC/PR curves with visualizations 
across CVs with different feature counts and an average ROC/PR curve for 
user-selected feature counts. 

* [**"Model performance"**](#eval) provides many valuable indicators for users to 
evaluate model performance. For each feature number, we calculate and plot the 
average value and 95% confidence interval of accuracy, sensitivity (recall), 
specificity, positive predictive value (precision), negative predictive value, 
F1 score, prevalence, detection rate, detection prevalence, and balanced accuracy 
in all CV runs. 

* [**"Predicted probability"**](#prob) displays the average predicted probabilities 
for each sample in the testing data across all CV runs, allowing users to explore 
incorrect or uncertain labels. 

* [**"Feature importance"**](#feaimp) offers tools to explore each feature's 
contribution. The two methods available, 'Algorithm-based' and 'SHAP analysis,' 
allow for ranking and visualizing feature importance.

* [**"Network"**](#network) allows users to examine feature interactions within a 
machine-learning model. In this section, users can select an optimal feature count 
based on prior cross-validation results. The top features from the best model 
(based on ROC-AUC and PR-AUC) will be used to calculate correlation coefficients 
between them.

## ROC/PR curve {#rocpr}
Receiver Operating Characteristic (ROC) and Precision-Recall (PR) curves are commonly
used to assess the diagnostic performance of binary classifiers. The mean AUC and 
95% confidence interval for each feature count for both ROC and PR curves are calculated 
across all cross-validation (CV) runs. Generally, a higher AUC indicates better model 
performance. The PR curve is especially useful for datasets with a highly imbalanced 
class distribution (i.e., rare positive samples), providing a more informative measure 
of an algorithm’s effectiveness in these cases [@davis2006relationship]. A random 
classifier typically yields an ROC-AUC around 0.5 and a PR-AUC close to the positive 
sample proportion. Conversely, an AUC of 1 for both metrics indicates perfect model performance.

To combine the testing results from all CV runs, 300 thresholds are evenly distributed 
from 0 to 1. The thresholds are then calculated for the corresponding sensitivity, 
specificity, precision, and recall with predicted probabilities and accurate labels of 
testing samples in each CV. These values are then averaged to plot a final ROC and PR curve. 

Now, we are going to conduct calculation for plotting ROC curves first, and then the PR curves.

```{r ml_analysis: ROC curves}
# plotting ROC curves
roc_result <- plot_ml_roc(ml_se, feature_num=10)

# result summary
summary(roc_result)
```

The ROC curve is generated by plotting 'sensitivity' (the proportion of correctly 
classified positive samples) on the y-axis against '1-specificity' (the proportion 
of correctly classified negative samples) on the x-axis, using various threshold values.
Generally, a more robust model will have an ROC curve approaching the upper left corner

```{r}
# view result: ROC curve plot
roc_result$static_mean_auc
```

**ROC curve plot**
The plot shows the average ROC curve for different feature numbers with their mean 
AUC and 95\% confidence interval.

```{r}
# view result: average ROC curve plot of 10 features
roc_result$static_roc
```

**Average ROC curve plot of 10 features**
The plot displays average ROC curves of user-defined features. Each CV is in grey, 
and the red line is the average of those cross-validations (CVs) for the ROC curves.

```{r ml_analysis: PR curve}
# plotting PR curves
pr_result <- plot_ml_pr(ml_se, feature_num=10)

# result summary
summary(pr_result)
```

The PR curve plots 'precision' (the proportion of actual positives out of 
predicted positive samples) on the y-axis and 'recall' (equal to sensitivity) on the x-axis. 
Generally, a more robust model will have a PR curve closer to the upper right corner.

```{r}
# view result: PR curve plot
pr_result$static_mean_auc
```

**PR curve plot**
The plot shows the average PR curve for different feature numbers with their mean 
AUC and 95\% confidence interval.

```{r}
# view result: average PR curve plot of 10 features
pr_result$static_pr
```

**Average PR curve plot of 10 features**
The plot displays the average PR curves of user-defined features. Each CV is in 
grey, and the red line is the average of those cross-validations (CVs) for the PR curves.


## Model performance {#eval}
After constructing the model, it is essential to evaluate its performance. We offer 
several valuable indicators for this purpose. For each feature count, we calculate 
and plot the average value and 95\% confidence interval of metrics such as accuracy, 
sensitivity (recall), specificity, positive predictive value (precision), negative 
predictive value, F1 score, prevalence, detection rate, detection prevalence, and 
balanced accuracy across all CV runs using the confusion matrix function in the 
caret package. Each of these indicators is defined in terms of true positives (TP), 
false positives (FP), false negatives (FN), and true negatives (TN).

Here, all the provided evaluation indicators are listed below. We can define the 
evaluation method by the parameter `eval_method`.

* Sensitivity = Recall $= \frac{TP}{(TP + FN)}$

* Specificity $= \frac{TN}{(FP + TN)}$

* Prevalence $= \frac{(TP + FN)}{(TP + FP + FN + TN)}$

* Positive predictive value (PPV) = Precision $= \frac{TP}{(TP + FP)}$

* Negative predictive value (NPV) $= \frac{TN}{(FN + TN)}$

* Detection rate $= \frac{TP}{(TP + FP + FN + TN)}$

* Detection prevalence $= \frac{(TP + FP)}{(TP + FP + FN + TN)}$

* F1 score $= \frac{2 \times Precision \times Recall}{(Precision + Recall)}$ 

```{r ML: model performance}
# conduct model evaluation
eval_result <- plot_ml_evaluation(ml_se, eval_method='Accuracy')

# result summary
summary(eval_result)

# view result: model performance plot
eval_result$static_evaluation_plot
```

**Model performance (Accuracy)**
The evaluation plot shows the model performance of accuracy. The highest value is marked in red.


## Predicted probability {#prob}
The average predicted probabilities for each sample in the testing data across all 
CV runs help us identify and investigate incorrect or uncertain labels.

```{r ML: predicted probability}
# compute and visualize the average predicted probabilities
prob_result <- plot_ml_probability(ml_se, feature_num=10)

# result summary
summary(prob_result)

# view result: the distribution of predicted probabilities
prob_result$static_probability_plot
```

**Probability plot**
In the plot showing the distribution of average sample probabilities across all 
CV runs, each point represents a sample, with its value being the mean prediction 
from all models in all cross-validations. The y-axis displays the predicted 
probabilities, indicating the likelihood that each machine learning model predicts 
a value of one. Specifically, the blue group represents samples where both the 
actual and predicted values are one, while the black group represents samples 
where the actual value is zero but the predicted value is one. Ideally, the black 
group should be as close to zero as possible, while the blue group should be as close to one.

```{r}
# view result: confusion matrix of sample number and proportion
prob_result$static_confusion_matrix
```

**Confusion matrix**
In the confusion matrix, the y-axis indicates the predicted class, and the x-axis 
is the actual class. Therefore, the upper left is a true positive, the upper right 
is a false positive, the lower left is a false negative, and the lower right is a 
true negative. The numbers are the counts, and the number in the bracket is the percentage.

## Feature importance {#feaimp}
After building a high-accuracy model, we examine each feature's contribution. 
Two methods, **'Algorithm-based'** and **'SHAP analysis'**, are provided to rank 
and visualize feature importance.

### Algorithm-based
In the **'Algorithm-based'** section, setting a specific feature count using the 
`feature_num` parameter displays the selection frequency and average importance of 
the top 10 features across all CV runs. For models like Linear SVM, Lasso, Ridge, 
and ElasticNet, feature importance will be based on their coefficients' absolute 
values, and Random Forest and XGBoost use their built-in feature importance metrics.

```{r ML: feature importance_algorithm-based}
# compute and rank the contribution of each feature
feature_result <- plot_ml_feature(ml_se, feature_num=10)

# result summary
summary(feature_result)

# view result: selected frequency plot
feature_result$static_selected_frequency
```

### SHAP analysis
The Shapley Additive exPlanations (SHAP) method was recently introduced to explain 
individual predictions for any machine learning model based on Shapley values from 
game theory. For more detailed information, refer to the paper "A Unified Approach 
to Interpreting Model Predictions" (2017) [@lundberg2017unified]. 

The analysis relies on ROC-AUC and PR-AUC results. The feature number can be set 
using the `feature_num` parameter. Based on this specified feature count, the 
best-performing model across all CVs is selected to compute approximate Shapley 
values for each feature for all samples using the `fastshap` package in R.

```{r ML: SHAP analysis}
# conduct SHAP
shap_se <- ml_shap(ml_se, feature_num=10, nsim=5)

# view SHAP analysis
shap_result <- extract_summarized_experiment(shap_se)

# result summary
summary(shap_result)
```

After running the above code, a SummarizedExperiment object `shap_se` will be 
returned. It includes the input abundance data, lipid characteristic table, 
group information table, analysis results, and input parameter settings. 
You can view the data in `shap_se` by `LipidSigR::extract_summarized_experiment`.

Then, you can continue to visualize the SHAP results using `LipidSigR::plot_ml_shap`.

```{r ML: SHAP analysis plotting}
library(SHAPforxgboost)

# plot SHAP results
shap_plots <- plot_ml_shap(shap_se)

# result summary
summary(shap_plots)

# view result: SHAP feature importance plot
shap_plots$static_feature_importance
```

**SHAP feature importance plot**
The top 10 features are ranked and demonstrated according to the average absolute 
value of shapely values from all samples.


```{r}
# view result: SHAP summary plot
shap_plots$static_summary_plot
```

**SHAP summary plot**
The SHAP summary plot illustrates the distribution of all shapely values for each 
feature. It uses Sina plot to present important features by binary patterns. The 
color exemplifying the value of the feature from low (yellow) to high (purple) 
indicates the variable is high/low for that observation. The x-axis presents whether 
the impact is positive or negative on quality rating (target variable). In the 
summary plot, the relationship between the value of a feature and the influence on 
the prediction is shown.

Next, we are going to visualize the SHAP feature importance of N samples.

```{r ML: SHAP analysis_sample}
# sample list
sample_id_list <- unique(S4Vectors::metadata(shap_se)$shap_result$ID)

# visualize SHAP feature importance of 10 samples
sample_plots <- plot_shap_sample(shap_se, sample_id=sample_id_list[10])

# result summary
summary(sample_plots)

# view result: SHAP feature importance plot of 10 samples
sample_plots$static_sample_feature_importance  
```

**SHAP feature importance of 10 samples**


Lastly, we build the SHAP force plot and dependence plot with different parameter sets.

The SHAP force plot visualizes stacked Shapley values, illustrating how selected 
features impact the final output for each sample. The `top_feature` parameter allows 
users to set the number of top features to display, while the `group_num` parameter 
defines the number of clusters for grouping the samples.

```{r ML: SHAP analysis_forceplot}
# visualize each predictor’s attributions
force_plots <- plot_shap_force(
    shap_se, top_feature=10, cluster_method="ward.D", group_num=10)

# result summary
summary(force_plots)

# view result: SHAP force plot
force_plots$static_forcePlot
```

**SHAP force plot**
The colors of the bars are filled according to the features.

The SHAP dependence plot enables exploration of how the model output varies with 
different feature values, revealing whether the relationship between the target 
variable and the feature is linear, monotonic, or more complex.

The x-axis, y-axis, and color of the plot can be customized. Typically, the x-axis 
represents the value of a specific feature, while the y-axis shows the corresponding
Shapley value. The color parameter can be set to examine potential interaction effects 
between a second feature and the plotted feature.

```{r ML: SHAP analysis_dependence_plot}
# feature lists
selected_feature <- as.character(unique(S4Vectors::metadata(shap_se)$shap_result$variable))

# visualize SHAP values against feature values for each variable
depend_plots <- plot_shap_dependence(
    shap_se, feature=selected_feature[1], shap_feature=selected_feature[2],
    interaction_index=selected_feature[2])

# result summary
summary(depend_plots)

# view result: SHAP dependence plot
depend_plots$static_dependence_plot
```

**SHAP dependence plot**


## Network {#network}
A correlation network enables us to examine interactions between features in a 
machine-learning model. Based on prior cross-validation results, an optimal feature 
count can be selected. The features from the best-performing model (based on 
ROC-AUC and PR-AUC) are then used to calculate correlation coefficients between 
each pair of features.

Nodes (features) are shaded based on their importance in constructing the network, 
while line width represents the correlation coefficient value between features. 
Two methods, 'Algorithm-based' and 'SHAP analysis,' are available for evaluating 
the importance of features. Detailed information on these methods can be found in 
the [Feature Importance section](#feaimp). In SHAP analysis, a positive or negative 
sign is assigned to feature importance based on the direction of feature values 
relative to the Shapley values of samples.

```{r ML: network}
# compute correlation coefficients and visualize correlation network
ml_network <- ml_corr_network(
    ml_se, feature_importance='Algorithm-based', correlation='pearson', 
    edge_cutoff=0, feature_num=10, nsim=5)

# result summary
summary(ml_network)

# view result: the network of feature importance
ml_network$static_correlation_network 
```

**The network of feature importance**

## Correlation {#corr}
Correlation analysis can be performed on either **"lipid species"** or **"lipid characteristics"**.

* **Lipid Species Analysis**: Data is analyzed at the individual lipid species level.
* **Lipid Characteristics Analysis**: Data is aggregated by specific lipid characteristics. The abundance of all lipid species in the same categories of a selected characteristic is summed up for analysis. 
    
This section is designed for continuous clinical data. The `condition_col` parameter 
specifies the column name from the group information table that defines the clinical 
conditions for analysis. Please ensure the selected columns contain only numerical data 
(e.g., integers, floats).
*NOTE: The condition_col must include at least two clinical conditions.*

Two correlation analyses are accessible: **'Correlation Coefficient'** and **'Linear Regression'**. 
Heatmaps will be shown once the correlation analysis is completed, it depicts the pattern 
between lipid species/lipid characteristics and clinical features. 
    
The available clustering methods are as follows. 

* Distance measurement: Pearson, Spearman, Kendall, Euclidean, Maximum, Manhattan, Canberra, Binary, and Minkowski.
* Clustering method: median, average, single, complete, Ward.D, Ward.D2, WPGMA, and UPGMC

All the analysis have to be conducted after data processing.
```{r}
# data processing
processed_corr <- data_process(
    corr_input, exclude_missing=TRUE, exclude_missing_pct=70, 
    replace_na_method='min',  replace_na_method_ref=0.5, 
    normalization='Percentage', transform='log10')
```

### Correlation coefficient {#correlation}
The Correlation Coefficient gives a summary view of whether a relationship exists 
between clinical features and lipid species, how strong that relationship is, 
and whether the relationship is positive or negative. The parameters' 
`cor_coef_cutoff` and `p_cutoff` can decide the correlation coefficient and p-value 
cut-offs. The rule of thumb in medical research recommended by Mukaka for 
interpreting the size of a correlation coefficient is provided below [@mukaka2012guide].


Size of Correlation          | Interpretation                             
-----------------------------|--------------------------------------------                   
0.90 to 1.00 (-.90 to -1.00) | Very high positive (negative) correlation
0.70 to .90 (-.70 to -.90)   | High positive (negative) correlation 
0.50 to .70 (-.50 to -.70)   | Moderate positive (negative) correlation
0.30 to .50 (-.30 to -.50)   | Low positive (negative) correlation     
0.00 to .30 (.00 to -.30)    | negligible correlation

First, we will conduct a correlation analysis for lipid species. Set the `type` parameter to `Sp`.
You can optionally visualize the heatmap with side colors. To do this, specify 
the desired characteristic in the `side_color_char` parameter. Here, we use `class` 
as an example. If you prefer not to display side colors, set `side_color_char` to NULL.
*NOTE: The `char` parameter must be set to NULL for lipid species correlation.*

Before the analysis, we must determine the `condition_col` parameter, selected from 
the column names from the group information table. Follow the steps below to view 
all available options for `condition_col`.
```{r}
# extract group information table
group_info <- extract_summarized_experiment(processed_corr)$group_info

# condition_col options (choose only columns with numeric values)
condition_col_option <- str(group_info[-1])
```

```{r Correlation_correlation_Sp}
# list the available lipid characteristics for `side_color_char`
list_lipid_char(processed_corr)$common_list

# compute correlation coefficient and visualize by heatmap
res_sp <- corr_cor_heatmap(
    processed_corr, char=NULL, 
    condition_col=c("FEV1_FVC", "Emphysema", "Exacerbations"),
    side_color_char='class', correlation='pearson', significant='pval',
    p_cutoff=1, adjust_p_method='BH', cor_coef_cutoff=0, 
    distfun='spearman', hclustfun='average', heatmap_col='statistic', 
    transform='log10', type='Sp')

# result summary
summary(res_sp)
```

```{r}
# view result: heatmap of clinical features and lipid species
res_sp$static_heatmap
```

**Correlation coefficient for lipid species analysis** The heatmap shows only the 
variables that pass the defined cut-offs for the p-value and the correlation 
coefficient. The rows are clinical features, and the columns are the lipid species.

Next, we move on to conduct a correlation analysis of lipid characteristics.
Set the `type` parameter to `Char` and specify a lipid characteristic for the 
`char` parameter. You can use `LipidSigR::list_lipid_char` to view a list of 
available lipid characteristics. For more detailed information, 
please refer to `vignette("tool_function")`.

*NOTE: The `side_color_char` parameter must be set to NULL for lipid characteristics correlation.*
```{r Correlation_correlation_char}
# list the available lipid characteristics for `char`
list_lipid_char(processed_corr)$common_list

# compute correlation coefficient and visualize by heatmap
res_char <- corr_cor_heatmap(
    processed_corr, char="class", 
    condition_col=c("FEV1_FVC", "Emphysema", "Exacerbations"),
    side_color_char=NULL, correlation='pearson', significant='pval',
    p_cutoff=1, adjust_p_method='BH', cor_coef_cutoff=0, 
    distfun='spearman', hclustfun='average', heatmap_col='statistic', 
    transform='log10', type='Char')

# result summary
summary(res_char)
```

```{r}
# view result: heatmap of clinical features and lipid characteristics
res_char$static_heatmap
```

**Correlation coefficient for lipid characteristics analysis** The heatmap shows 
only the variables that pass the defined cut-offs for the p-value and the 
correlation coefficient. The rows are clinical features, and the columns are 
lipid characteristics.


### Linear regression {#lr}
Linear regression is a statistical method used to model the relationship between 
a dependent variable (e.g., lipid level) and one or more independent variables 
(e.g., clinical features). By analyzing these relationships, we can estimate the 
impact of specific clinical factors on lipid levels.

In multiple linear regression, we incorporate additional variables to account for 
potential confounding factors. To do this, we specify the `adjusted_col` parameter, 
which refers to the column names selected from the group information table. Once 
the analysis is complete, each lipid species is assigned a beta coefficient and 
a corresponding t-statistic (p-value). These values can be used to identify 
significant associations and group similar lipid species for further analysis.

First, we will conduct a correlation analysis for lipid species. Set the `type` parameter to `Sp`.
You can optionally visualize the heatmap with side colors. To do this, specify 
the desired characteristic in the `side_color_char` parameter. Here, we use `class` 
as an example. If you prefer not to display side colors, set `side_color_char` to NULL.

*NOTE: The `char` parameter must be set to NULL for lipid species correlation.*

Before the analysis, we must determine the `condition_col` and `adjusted_col` 
parameters, selected from the column names from the group information table. 
Follow the steps below to view all available options for `condition_col` and `adjusted_col`.
```{r}
# extract group information table
group_info <- extract_summarized_experiment(processed_corr)$group_info

# condition_col options (choose only columns with numeric values)
condition_col_option <- str(group_info[-1])

# adjusted_col options
adjusted_col_option <- str(group_info[-1])
```

```{r Correlation_lr_sp}
# list the available lipid characteristics for `side_color_char`
list_lipid_char(processed_corr)$common_list

# compute linear regression and visualize by heatmap
res_sp <- corr_lr_heatmap(
    processed_corr, char=NULL,
    condition_col=c("FEV1_FVC", "Emphysema", "Exacerbations"),
    adjusted_col=c("Age", "Sex", "Smoking", "BMI", "FEV1"),
    side_color_char=NULL, significant='pval', p_cutoff=0.05,
    adjust_p_method='BH', distfun='spearman', hclustfun='centroid',
    heatmap_col='t_statistic', transform='log10', type='Sp')

# result summary
summary(res_sp)
```

```{r}
# view result: heatmap of linear regression
res_sp$static_heatmap
```

**The heatmap of linear regression for lipid species analysis** The heatmap shows 
only the variables that pass the user-defined cut-offs for p-value and correlation 
coefficient. The rows are clinical features, and the columns are lipid species.

Next, we move on to conduct a correlation analysis of lipid characteristics.
Set the `type` parameter to `Char` and specify a lipid characteristic for the 
`char` parameter. You can use `LipidSigR::list_lipid_char` to view a list of 
available lipid characteristics. For more detailed information, 
please refer to `vignette("tool_function")`.

*NOTE: The `side_color_char` parameter must be set to NULL for lipid characteristics correlation.*
```{r Correlation_lr_char}
# list the available lipid characteristics for `char`
list_lipid_char(processed_corr)$common_list

# compute linear regression and visualize by heatmap
res_char <- corr_lr_heatmap(
    processed_corr, char="class",
    condition_col=c("FEV1_FVC", "Emphysema", "Exacerbations"),
    adjusted_col=c("Age", "Sex", "Smoking", "BMI", "FEV1"),
    side_color_char=NULL, significant='pval', p_cutoff=1,
    adjust_p_method='BH', distfun='spearman', hclustfun='centroid',
    heatmap_col='t_statistic', transform='log10', type='Char')

# result summary
summary(res_char)
```
```{r}
# view result: heatmap of linear regression
res_char$static_heatmap
```

**The heatmap of linear regression for lipid characteristics analysis** Only the 
variables that pass the user-defined cut-offs for p-value and correlation coefficient 
are shown on the heatmap. The rows of the heatmap are clinical features, and the 
columns are lipid characteristics.

# Session info
```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References
