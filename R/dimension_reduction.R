#' @title dr_pca
#' @description Principal Component Analysis (PCA) is a dimensionality reduction
#' method that transforms data from a high-dimensional space into a low-dimensional
#' space while retaining the original data's essential properties.
#' This function calculates PCA using the classical prcomp function and visualizes the results.
#' @param processed_se A SummarizedExperiment object constructed by
#' \code{\link{as_summarized_experiment}} and processed by \code{\link{data_process}}.
#' (NOTE: A SummarizedExperiment object generated by \code{\link{deSp_twoGroup}},
#'  \code{\link{deChar_twoGroup}}, \code{\link{deSp_multiGroup}}, or
#'  \code{\link{deChar_multiGroup}} is also allowed.)
#' @param scaling Logical. If scaling=TRUE, each block is
#' standardized to zero means and unit variances. Default is \code{TRUE}.
#' @param centering Logical. If centering=TRUE, the variables should be
#' shifted to be zero centered. Alternately, a vector of length equal the
#' number of columns of x can be supplied. The value is passed to scale. Default is \code{TRUE}.
#' @param clustering Character. The method to be used for clustering. Allowed method
#' include "kmeans", "kmedoids", "hclustering", "dbscan", "group_info". Default is \code{"kmeans"}.
#' @param cluster_num Numeric. A positive integer specifying the number of clusters.
#' The number must be between 1 and 10. Default is \code{2}.
#' @param kmedoids_metric Character. The metric to be used for calculating
#' dissimilarities between observations when choosing \code{"kmedoids"} as clustering method.
#' Must be one of "euclidean" and "manhattan". If "kmedoids" is not selected as
#' the clustering method, set the value to NULL.
#' @param distfun Character. The distance measure to be used when choosing \code{"hclustering"}
#' as clustering method. Allow method include "pearson", "kendall", "spearman",
#' "euclidean", "manhattan", "maximum", "canberra", "binary", and "minkowski".
#' If "hclustering" is not selected as the clustering method, set the value to NULL.
#' @param hclustfun Character. The agglomeration method to be used when choosing
#' \code{"hclustering"} as clustering method. This should be (an unambiguous abbreviation of)
#' one of "ward.D", "ward.D2", "single", "complete", "average" (=UPGMA),
#' "mcquitty" (= WPGMA), "median" (= WPGMC), or "centroid" (= UPGMC).
#' If "hclustering" is not selected as the clustering method, set the value to NULL.
#' @param eps Numeric. The size of the epsilon neighborhood when choosing \code{"dbscan"} as clustering method.
#' If "dbscan" is not selected as the clustering method, set the value to NULL.
#' @param minPts Numeric. The number of minimum points in the eps region (for core points)
#' when choosing \code{"dbscan"} as clustering method.
#' If "dbscan" is not selected as the clustering method, set the value to NULL.
#' @param feature_contrib_pc Numeric. The dimension(s) of interest.
#' @param plot_topN Numeric. The number of top elements to be shown.
#' @return Return a list with 2 tables, 4 interactive plots, and 4 static plots.
#' \enumerate{
#' \item pca_rotated_data: a data frame of PCA rotated data
#' \item table_pca_contribution: a data frame, PCA contribution table
#' \item interactive_pca & static_pca: PCA plot
#' \item interactive_screePlot & static_screePlot: Scree plot of top n principle components
#' \item interactive_feature_contribution & static_feature_contribution: plot, the contribution of top N features of the
#' user-defined principal components.
#' \item interactive_variablePlot & static_variablePlot: correlation circle plot(factor map) of PCA variables.
#' }
#' @export
#' @examples
#' data("profiling_data")
#' processed_se <- data_process(profiling_data, exclude_missing=TRUE, exclude_missing_pct=70,
#' replace_na_method='min', replace_na_method_ref=0.5, normalization='Percentage', transform='log10')
#' result_pca <- dr_pca(processed_se, scaling=TRUE, centering=TRUE,
#' clustering='kmeans', cluster_num=2, kmedoids_metric=NULL, distfun=NULL,
#' hclustfun=NULL, eps=NULL, minPts=NULL, feature_contrib_pc=c(1,2), plot_topN=10)
dr_pca <- function(
        processed_se, scaling=TRUE, centering=TRUE,
        clustering=c('kmeans', 'kmedoids', 'hclustering', 'dbscan', 'group_info'),
        cluster_num=2, kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL,
        eps=NULL, minPts=NULL, feature_contrib_pc=c(1,2), plot_topN=10){

    # check input parameter
    if (!is.logical(scaling)) {
        stop("scaling must be a logical value.")
    }
    if (!is.logical(centering)) {
        stop("centering must be a logical value.")
    }
    .dr_check(clustering, cluster_num, kmedoids_metric, distfun, hclustfun, eps, minPts)
    # check feature_contrib_pc
    .check_inputSE(processed_se, metadata_list=NULL)
    #if (is.null(names(S4Vectors::metadata(processed_se))) ) {
    if (all(names(S4Vectors::metadata(processed_se)) %in% c("processed_abund","transform")) &&
        length(names(S4Vectors::metadata(processed_se))) == 2) {
        abundance <- S4Vectors::metadata(processed_se)$processed_abund
        group_info <- NULL
    } else {
        de_data <- .deSig_data(de_se=processed_se)
        abundance <- de_data$abundance
        group_info <- de_data$group_info
    }

    if(!is.numeric(plot_topN) | isFALSE(.check_numeric_range(plot_topN, 1, nrow(abundance)))){
        stop('plot_topN must be a numeric value less than the number of lipids.')
    }
    pca_table <- .dim_process(abundance)
    color <- .dr_color()
    ## pca
    pca <- stats::prcomp(pca_table, scale=scaling, center=centering)
    ## grouping
    grouping <- .dim_grouping(
        pca$x, pca_table, group_info, clustering, cluster_num,
        kmedoids_metric, distfun, hclustfun, eps, minPts)
    cluster_group <- grouping$cluster_group
    cluster_num <- grouping$cluster_num
    ## output pca data
    pca_rotated_data <- as.data.frame(pca$x) %>%
        dplyr::mutate(sample_name=colnames(abundance)[-1])
    pca_rotated_data %<>% dplyr::mutate(group=cluster_group) %>%
        dplyr::select(sample_name, group, dplyr::everything())
    ## biplot
    pcaPlot <- suppressWarnings(
        .pca_plot(pca, clustering, cluster_group, cluster_num, color)
    )
    ## pca_plot
    screenPlot <- suppressWarnings( .screeplot(pca))
    featureContrib <- suppressWarnings(
        .feature_contrib(pca, feature_contrib_pc, plot_topN)
    )
    variablePlot <- suppressWarnings( .pca_variable(pca, plot_topN) )

    ## pca contribution table
    contrib_table <- factoextra::get_pca_var(pca)$contrib %>%
        as.data.frame() %>%
        dplyr::mutate(feature=rownames(.)) %>%
        dplyr::select(feature, dplyr::everything())
    PC <- ncol(contrib_table)-1
    colnames(contrib_table)[seq(2, ncol(contrib_table))] <-
        stringr::str_c('PC', as.character(seq_len(PC)))

    return(list(
        pca_rotated_data=pca_rotated_data,
        table_pca_contribution=contrib_table,
        interactive_pca=pcaPlot$biplot,
        interactive_screePlot=screenPlot$screeplot,
        interactive_feature_contribution=featureContrib$feature_contrib,
        interactive_variablePlot=variablePlot$pca_variable_ggplotly,
        static_pca=pcaPlot$pca_biplot,
        static_screePlot=screenPlot$pca_screeplot,
        static_feature_contribution=featureContrib$pca_feature_contrib,
        static_variablePlot=variablePlot$pca_variable))
}

.dr_check <- function(
        clustering, cluster_num, kmedoids_metric, distfun, hclustfun, eps, minPts) {
    if (is.null(clustering) | isFALSE(clustering %in% c('kmeans', 'kmedoids', 'hclustering', 'dbscan', 'group_info')) ) {
        stop("clustering must be one of 'kmeans', 'kmedoids', 'hclustering', 'dbscan', or 'group_info'.")
    }
    if(clustering != 'dbscan' ){
        if(!is.numeric(cluster_num) | isFALSE(.check_numeric_range(cluster_num, 1, 10))){
            stop('cluster_num must be a numeric value between 1 and 10.')
        }
    }
    if (clustering=='kmedoids') {
        if(is.null(kmedoids_metric) | isFALSE(kmedoids_metric %in% c("euclidean","manhattan")) ){
            stop('kmedoids_metric must be one of "euclidean" or "manhattan".')
        }
    }
    if (clustering=='hclustering') {
        if(is.null(distfun) | isFALSE(distfun %in% c("pearson", "spearman", "kendall", "euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski")) ){
            stop('distfun must be one of "pearson", "spearman", "kendall", "euclidean", "maximum", "manhattan", "canberra", "binary", or "minkowski".')
        }
        if(is.null(hclustfun) | isFALSE(hclustfun %in% c("ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median", "centroid")) ){
            stop('hclustfun must be one of "ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median", or "centroid".')
        }
    }
    if (clustering=='dbscan') {
        if(is.null(eps) | isFALSE(class(eps) %in% c("numeric", "integer")) | isFALSE(.check_numeric_range(eps, 0, NULL))){
            stop('eps must be must be numeric value >= 0.')
        }
        if(is.null(minPts) | isFALSE(class(minPts) %in% c("numeric", "integer")) | isFALSE(.check_numeric_range(minPts, 0, NULL))){
            stop('minPts must be must be numeric value >= 0.')
        }
    }
}

.deSig_data <- function(de_se) {
    .check_de_outputSE(de_se, de_type="all")
    abundance <- .extract_df(de_se, type = "abundance")
    group_info <- .extract_df(de_se, type = "group")
    if(!is.null(S4Vectors::metadata(de_se)[["sig_deChar_result"]])) {
        sig_table <- S4Vectors::metadata(de_se)[["sig_deChar_result"]]
    } else {
        sig_table <- S4Vectors::metadata(de_se)[["sig_deSp_result"]]
    }

    if (is.data.frame(sig_table)) {
        sig_feature <- sig_table$feature
        abundance <- abundance %>%
            dplyr::filter(eval(
                parse(text=colnames(abundance)[1])) %in% sig_feature)
        if (nrow(abundance) < 2) {
            stop('Insufficient number of significant lipids.')
        }
    } else {
        stop('Insufficient number of significant lipids.')
    }
    return (list(abundance=abundance, group_info=group_info))
}

.dim_process <- function(abundance){
    num <- apply(abundance[-1], 1, FUN=function(x){length(unique(x))})
    abundance <- abundance[(num!=1),]
    abundance <- abundance[!is.infinite(rowSums(
        abundance[-1], na.rm=TRUE)),]
    dim_process_table <- abundance[-1] %>% t() %>%
        as.data.frame()
    colnames(dim_process_table) <- abundance[[1]]
    dim_process_table <- stats::na.omit(dim_process_table)

    return(dim_process_table=dim_process_table)
}

.dr_color <- function() {
    color <- c("#00AFBB", "#E7B800", "#FC4E07", "#42B540FF", "#BB3099",
                        "#EE0099", "#0000AC", "#868686FF", '#00468BFF', 'black')

    return(color=color)
}

.dim_grouping <- function(
        dim, dim_table, group_info, clustering, cluster_num,
        kmedoids_metric, distfun, hclustfun, eps, minPts){
    if(clustering == 'kmeans'){
        cluster_group <- stats::kmeans(dim, centers=cluster_num)$cluster
    }else if(clustering == 'kmedoids'){
        cluster_group <- cluster::pam(
            dim, k=cluster_num, metric=kmedoids_metric)$cluster #euclidean manhattan
    }else if(clustering == 'hclustering'){
        if(distfun %in% c('pearson', 'spearman', 'kendall')){
            dist.fun <- function(x){
                x <- t(x)
                cor.mat <- stats::cor(x, method=distfun, use='complete.obs')
                cor.mat <- (1-cor.mat)
                cor.dist <- stats::as.dist(cor.mat)
                return(cor.dist)
            }
        }else{
            dist.fun <- function(x) stats::dist(x, method=distfun)
        }
        cluster_group <- stats::hclust(dist.fun(dim), method=hclustfun)
        cluster_group <- stats::cutree(cluster_group, k=cluster_num)
    }else if(clustering == 'dbscan'){
        cluster_group <- dbscan::dbscan(dim, eps=eps, minPts=minPts)$cluster
        cluster_group <- ifelse(
            cluster_group > 9, 9, cluster_group) %>% as.character()
        cluster_group <- ifelse(cluster_group == '0', 'noise', cluster_group)
    }else if(clustering == 'group_info'){
        group_order <- purrr::map_dbl(
            rownames(dim_table),
            function(x){which( x == group_info$sample_name)})
        cluster_group <- group_info[group_order, ] %>% .$group
        cluster_num <- length(unique(cluster_group))
    }
    return(list(cluster_group=cluster_group, cluster_num=cluster_num))
}

.pca_plot <- function(pca, clustering, cluster_group, cluster_num, color){
    if(clustering %in% c('dbscan')){
        pca_biplot <- factoextra::fviz_pca_ind(
            pca,label="none", habillage=cluster_group,
            palette=color[seq_len(length(unique(cluster_group)))],
            addEllipses=FALSE, invisible="quali", title='PCA')
        biplot <- plotly::ggplotly(pca_biplot)
        for (i in seq_len(length(biplot$x$data))){
            if (!is.null(biplot$x$data[[i]]$name)){
                biplot$x$data[[i]]$name <- gsub(
                    "\\(", "", stringr::str_split(biplot$x$data[[i]]$name, ",")[[1]][1])
            }
            if(i <= length(unique(cluster_group))){
                biplot$x$data[[i]]$text <- paste(
                    "x :",  round(biplot$x$data[[i]]$x, 3),
                    "\ny :", round(biplot$x$data[[i]]$y, 3),
                    "\nGroups :", biplot$x$data[[i]]$name,
                    "\nSample name :", pca_biplot$data[which(
                        pca_biplot$data$Groups == biplot$x$data[[i]]$name), ]$name)
            }
        }
    }else{
        pca_biplot <- factoextra::fviz_pca_ind(
            pca, label="none", habillage=cluster_group,
            palette=color[seq_len(cluster_num)], addEllipses=TRUE, invisible="quali", title='PCA')
        biplot <- plotly::ggplotly(pca_biplot)
        for (i in seq_len(length(biplot$x$data))){
            if (!is.null(biplot$x$data[[i]]$name)){
                biplot$x$data[[i]]$name <- gsub(
                    "\\(", "", stringr::str_split(biplot$x$data[[i]]$name, ",")[[1]][1])
            }
            if (i <= cluster_num){
                biplot$x$data[[i]]$text <- paste(
                    "Dim1 :", round(biplot$x$data[[i]]$x, 3), "\nDim2 :",
                    round(biplot$x$data[[i]]$y, 3), "\nGroups :",
                    biplot$x$data[[i]]$name, "\nSample name :",
                    pca_biplot$data[which(pca_biplot$data$Groups==biplot$x$data[[i]]$name),]$name)
            }else if(i >= cluster_num+1 & i <= 2*cluster_num){
                biplot$x$data[[i]]$text <- paste("\nGroups :", biplot$x$data[[i]]$name)
            }
        }
        for (i in seq_len((2*cluster_num))) {
            rev_n <- rev(seq_len((2*cluster_num)))
            if (i== 1) {
                rev_list <- list(biplot$x$data[[rev_n[i]]])
            } else {
                rev_list <- c(rev_list, list(biplot$x$data[[rev_n[i]]]))
            }
        }
        biplot$x$data <- rev_list
    }
    return(list(biplot=biplot, pca_biplot=pca_biplot))
}

.screeplot <- function(pca){
    pca_screeplot <- factoextra::fviz_screeplot(
        pca, ncp=10, main="Scree plot for Top10 PCs",
        xlab="Principle components (PCs)", ylab='Explained variance (%)')
    screeplot <- plotly::ggplotly(pca_screeplot) %>%
        plotly::style(
            traces=seq_len(2), hoverinfo="text", text=paste(
                "Principle components :", pca_screeplot$data$dim,
                "\nExplained variance :", round(pca_screeplot$data$eig, 3),"%"))
    return(list(screeplot=screeplot, pca_screeplot=pca_screeplot))
}

.feature_contrib <- function(pca, feature_contrib_pc, plot_topN){
    pca_feature_contrib <- factoextra::fviz_contrib(
        pca, choice="var", addlabels=TRUE, axes=feature_contrib_pc, top=plot_topN,
        title=stringr::str_c(
            'Contribution of Top', as.character(plot_topN),
            ' features to PC-', stringr::str_c(
                as.character(feature_contrib_pc),collapse=',')))
    feature_contrib <- plotly::ggplotly(pca_feature_contrib)
    feature_contrib$x$data[[1]]$text <- paste(
        "Feature :", feature_contrib$x$layout$xaxis$categoryarray,
        "\nContributions :", round(feature_contrib$x$data[[1]]$y, 3),"%")
    feature_contrib$x$data[[2]]$text <- paste(
        "yintercept :", round(feature_contrib$x$data[[2]]$y[1], 3))
    return(list(feature_contrib=feature_contrib,
                pca_feature_contrib=pca_feature_contrib))
}

.pca_variable <- function(pca, plot_topN){
    eig.val <- factoextra::get_eigenvalue(pca)

    pca_variable <- factoextra::fviz_pca_var(
        pca, col.var="contrib", select.var=list(contrib=plot_topN),
        gradient.cols=c("#00AFBB", "#E7B800", "#FC4E07"),
        repel=TRUE, title='Variables - PCA',
        xlab=stringr::str_c(
            "PC1 (", as.character(round(eig.val[1, 2], 1)), '%)'),
        ylab=stringr::str_c(
            "PC2 (", as.character(round(eig.val[2, 2], 1)), '%)'))
    pca_variable$data <- dplyr::arrange(pca_variable$data,contrib)
    pca_variable_ggplotly <- plotly::ggplotly(pca_variable)
    for (i in 1:nrow(pca_variable$data)) { #seq_len(plot_topN)
        pca_variable_ggplotly <- pca_variable_ggplotly %>%
            plotly::add_annotations(
                data=pca_variable$data[i,], x=~x, y=~y, text="",
                arrowcolor=pca_variable_ggplotly$x$data[[i+1]]$line$color,
                showarrow=TRUE, axref='x', ayref='y', ax=0, ay=0)
        pca_variable_ggplotly$x$data[[i+1]]$text <- paste(
            "X :", round(pca_variable$data$x[i], 3), "\nY :",
            round(pca_variable$data$y[i], 3), "\nName :",
            pca_variable$data$name[i])
    }
    #pca_variable_ggplotly$x$data[[plot_topN+2]]$hoverinfo <- "none"

    if(plot_topN > ncol(pca$rotation)){
        plot_topN <- ncol(pca$rotation)
        warning_message <- paste0(
            "plot_topN will only show ", ncol(pca$rotation))
        warning(warning_message)
    }
    return(list(pca_variable_ggplotly=pca_variable_ggplotly,
                pca_variable=pca_variable))
}

#' @title dr_tsne
#' @description t-distributed stochastic neighbor embedding (t-SNE) is a dimensionality reduction
#' method that transforms data from a high-dimensional space into a low-dimensional
#' space while retaining the original data's essential properties.
#' @param processed_se A SummarizedExperiment object constructed by
#' \code{\link{as_summarized_experiment}} and processed by \code{\link{data_process}}.
#' (NOTE: A SummarizedExperiment object generated by \code{\link{deSp_twoGroup}},
#'  \code{\link{deChar_twoGroup}}, \code{\link{deSp_multiGroup}}, or
#'  \code{\link{deChar_multiGroup}} is also allowed.)
#' @param pca Logical. If pca=TRUE, an initial PCA step will be performed. Default is \code{TRUE}.
#' @param perplexity Numeric. Perplexity parameter (should not be bigger than 3 * perplexity < nrow(X) - 1.
#' @param max_iter Integer. Number of iterations.
#' @param clustering Character. The method to be used for clustering. Allowed method
#' include "kmeans", "kmedoids", "hclustering", "dbscan", "group_info". Default is \code{"kmeans"}.
#' @param cluster_num Numeric. A positive integer specifying the number of clusters.
#' The number must be between 1 and 10. Default is \code{2}.
#' @param kmedoids_metric Character. The metric to be used for calculating
#' dissimilarities between observations when choosing \code{"kmedoids"} as clustering method.
#' Must be one of "euclidean" and "manhattan". If "kmedoids" is not selected as
#' the clustering method, set the value to NULL.
#' @param distfun Character. The distance measure to be used when choosing \code{"hclustering"}
#' as clustering method. Allow method include "pearson", "kendall", "spearman",
#' "euclidean", "manhattan", "maximum", "canberra", "binary", and "minkowski".
#' If "hclustering" is not selected as the clustering method, set the value to NULL.
#' @param hclustfun Character. The agglomeration method to be used when choosing
#' \code{"hclustering"} as clustering method. This should be (an unambiguous abbreviation of)
#' one of "ward.D", "ward.D2", "single", "complete", "average" (=UPGMA),
#' "mcquitty" (= WPGMA), "median" (= WPGMC), or "centroid" (= UPGMC).
#' If "hclustering" is not selected as the clustering method, set the value to NULL.
#' @param eps Numeric. The size of the epsilon neighborhood when choosing \code{"dbscan"} as clustering method.
#' If "dbscan" is not selected as the clustering method, set the value to NULL.
#' @param minPts Numeric. The number of minimum points in the eps region (for core points)
#' when choosing \code{"dbscan"} as clustering method.
#' If "dbscan" is not selected as the clustering method, set the value to NULL.
#' @return Return a list with 1 data frame, 1 interactive plot, and 1 static plot.
#' \enumerate{
#' \item tsne_result: a data frame of tsne data.
#' \item interactive_tsne & static_tsne: tsne plot.
#' }
#' @export
#' @examples
#' data("profiling_data")
#' processed_se <- data_process(profiling_data, exclude_missing=TRUE, exclude_missing_pct=70,
#'     replace_na_method='min', replace_na_method_ref=0.5, normalization='Percentage', transform='log10')
#' result_tsne <- dr_tsne(processed_se, pca=TRUE, perplexity=5, max_iter=500, clustering='kmeans',
#'     cluster_num=2, kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, eps=NULL, minPts=NULL)
dr_tsne <- function(
        processed_se, pca=TRUE, perplexity=5, max_iter=500,
        clustering=c('kmeans', 'kmedoids', 'hclustering', 'dbscan', 'group_info'),
        cluster_num=2, kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, eps=NULL, minPts=NULL){


    if (!is.logical(pca)) {
        stop("pca must be a logical value.")
    }
    if(!is.numeric(perplexity) | isFALSE(.check_numeric_range(perplexity, 0, NULL))){
        stop('perplexity cannot be a negative value.')
    }
    if(!is.numeric(max_iter) | isFALSE(.check_numeric_range(max_iter, 0, NULL))){
        stop('max_iter cannot be a negative value.')
    }
    .dr_check(clustering, cluster_num, kmedoids_metric, distfun, hclustfun, eps, minPts)
    # check SE
    .check_inputSE(processed_se, metadata_list=NULL)
    #if (is.null(names(S4Vectors::metadata(processed_se))) ) {
    if (all(names(S4Vectors::metadata(processed_se)) %in% c("processed_abund","transform")) &&
        length(names(S4Vectors::metadata(processed_se))) == 2) {
        abundance <- S4Vectors::metadata(processed_se)$processed_abund
        group_info <- NULL
    } else {
        de_data <- .deSig_data(de_se=processed_se)
        abundance <- de_data$abundance
        group_info <- de_data$group_info
    }
    tsne_table <- .dim_process(abundance)
    color <- .dr_color()
    tsne <- Rtsne::Rtsne(
        tsne_table, check_duplicates=FALSE , pca=pca, perplexity=perplexity,
        verbose=TRUE, max_iter=max_iter,theta=0)
    tsne_data <- as.data.frame(tsne$Y) %>% dplyr::mutate(sample_name=colnames(abundance)[-1])
    colnames(tsne_data)[seq_len(2)] <- c('tsne1', 'tsne2')
    ## grouping
    grouping <- .dim_grouping(
        tsne$Y, tsne_table, group_info, clustering, cluster_num,
        kmedoids_metric, distfun, hclustfun, eps, minPts)
    cluster_group <- grouping$cluster_group
    cluster_group <- as.character(cluster_group)
    cluster_num <- grouping$cluster_num
    tsne_data %<>% dplyr::mutate(group=cluster_group) %>%
        dplyr::select(sample_name, group, dplyr::everything())
    ## ploting
    res <- .tsne_ploting(tsne, tsne_data, clustering, cluster_group, cluster_num, color)

    return(list(tsne_result=tsne_data, interactive_tsne=res$in_tsne, static_tsne=res$tsne_plot))
}

.tsne_ploting <- function(
        tsne, tsne_data, clustering, cluster_group, cluster_num, color){
    if(clustering %in% c('dbscan')){
        tsne_plot <- factoextra::fviz_cluster(
            list(data=as.data.frame(tsne$Y), cluster=cluster_group),
            palette=color[seq_len(length(unique(cluster_group)))],
            geom="point",  stand=FALSE, ellipse=FALSE,
            ggtheme=ggplot2::theme_bw(), show.clust.cent=FALSE, xlab='tsne-1',
            ylab='tsne-2', main="t-SNE", legend.title="Groups")
        in_tsne <- plotly::ggplotly(tsne_plot)
        for (i in seq_len(length(in_tsne$x$data))){
            if (!is.null(in_tsne$x$data[[i]]$name)){
                in_tsne$x$data[[i]]$name <-  gsub("\\(", "", stringr::str_split(in_tsne$x$data[[i]]$name, ",")[[1]][1])
            }
            if(i<=length(unique(cluster_group))){
                in_tsne$x$data[[i]]$text <- paste(
                    "x :", round(in_tsne$x$data[[i]]$x, 3), "\ny :",
                    round(in_tsne$x$data[[i]]$y, 3), "\nGroups :",
                    in_tsne$x$data[[i]]$name, "\nSample name :",
                    tsne_data[which(tsne_data$group == in_tsne$x$data[[i]]$name),]$sample_name)
            }
        }
    }else{
        tsne_plot <- factoextra::fviz_cluster(
            list(data=as.data.frame(tsne$Y), sample_id=tsne_data$sample_name,
                 cluster=cluster_group),palette=color[seq_len(cluster_num)],
            geom="point", stand=FALSE, ellipse=TRUE, ellipse.type='norm',
            ggtheme=ggplot2::theme_bw(), show.clust.cent=FALSE, xlab='tsne-1',
            ylab='tsne-2', main="t-SNE", legend.title="Groups")
        in_tsne <- plotly::ggplotly(tsne_plot)
        for (i in seq_len(length(in_tsne$x$data))){
            if (!is.null(in_tsne$x$data[[i]]$name)){
                in_tsne$x$data[[i]]$name <- gsub("\\(", "", stringr::str_split(in_tsne$x$data[[i]]$name, ",")[[1]][1])
            }
            if(i <= cluster_num){
                in_tsne$x$data[[i]]$text <- paste(
                    "x :", round(in_tsne$x$data[[i]]$x, 3), "\ny :",
                    round(in_tsne$x$data[[i]]$y, 3), "\nGroups :",
                    in_tsne$x$data[[i]]$name, "\nSample name :",
                    tsne_data[which(tsne_data$group == in_tsne$x$data[[i]]$name),]$sample_name)
            }else if(i >= cluster_num+1 & i <= 2*cluster_num){
                in_tsne$x$data[[i]]$text <- paste("\nGroups :", in_tsne$x$data[[i]]$name)
            }
        }
        for (i in seq_len((2*cluster_num))) {
            rev_n <- rev(seq_len((2*cluster_num)))
            if(i == 1){rev_list <- list(in_tsne$x$data[[rev_n[i]]])}
            else{rev_list<-c(rev_list, list(in_tsne$x$data[[rev_n[i]]]))}
        }
        in_tsne$x$data <- rev_list
    }
    return(list(in_tsne=in_tsne, tsne_plot=tsne_plot))
}

#' @title dr_umap
#' @description Uniform Manifold Approximation and Projection (UMAP) is a dimensionality reduction
#' method that transforms data from a high-dimensional space into a low-dimensional
#' space while retaining the original data's essential properties.
#' @param processed_se A SummarizedExperiment object constructed by
#' \code{\link{as_summarized_experiment}} and processed by \code{\link{data_process}}.
#' (NOTE: A SummarizedExperiment object generated by \code{\link{deSp_twoGroup}},
#'  \code{\link{deChar_twoGroup}}, \code{\link{deSp_multiGroup}}, or
#'  \code{\link{deChar_multiGroup}} is also allowed.)
#' @param n_neighbors Numeric. The size of local neighborhood (in terms of number of
#' neighboring sample points) used for manifold approximation.
#' @param scaling Logical/Character. Scaling to apply to \bold{X} if it is a data frame or matrix:
#' \itemize{
#'   \item \code{"none"} or \code{FALSE} or \code{NULL}: No scaling.
#'   \item \code{"Z"} or \code{"scale"} or \code{TRUE}: Scale each column to
#'   zero mean and variance 1.
#'   \item \code{"maxabs"}: Center each column to mean 0, then divide each
#'   element by the maximum absolute value over the entire matrix.
#'   \item \code{"range"}: Range scale the entire matrix, so the smallest
#'   element is 0 and the largest is 1.
#'   \item \code{"colrange"}: Scale each column in the range (0,1).
#' }
#' Default is \code{TRUE}.
#' @param umap_metric Character. Type of distance metric to use to find nearest neighbors.
#' One of "euclidean", "cosine", "manhattan", "hamming", "categorical". Default is \code{'euclidean'}.
#' @param clustering Character. The method to be used for clustering. Allowed method
#' include "kmeans", "kmedoids", "hclustering", "dbscan", "group_info". Default is \code{"kmeans"}.
#' @param cluster_num Numeric. A positive integer specifying the number of clusters.
#' The number must be between 1 and 10. Default is \code{2}.
#' @param kmedoids_metric Character. The metric to be used for calculating
#' dissimilarities between observations when choosing \code{"kmedoids"} as clustering method.
#' Must be one of "euclidean" and "manhattan". If "kmedoids" is not selected as
#' the clustering method, set the value to NULL.
#' @param distfun Character. The distance measure to be used when choosing \code{"hclustering"}
#' as clustering method. Allow method include "pearson", "kendall", "spearman",
#' "euclidean", "manhattan", "maximum", "canberra", "binary", and "minkowski".
#' If "hclustering" is not selected as the clustering method, set the value to NULL.
#' @param hclustfun Character. The agglomeration method to be used when choosing
#' \code{"hclustering"} as clustering method. This should be (an unambiguous abbreviation of)
#' one of "ward.D", "ward.D2", "single", "complete", "average" (=UPGMA),
#' "mcquitty" (= WPGMA), "median" (= WPGMC), or "centroid" (= UPGMC).
#' If "hclustering" is not selected as the clustering method, set the value to NULL.
#' @param eps Numeric. The size of the epsilon neighborhood when choosing \code{"dbscan"} as clustering method.
#' If "dbscan" is not selected as the clustering method, set the value to NULL.
#' @param minPts Numeric. The number of minimum points in the eps region (for core points)
#' when choosing \code{"dbscan"} as clustering method.
#' If "dbscan" is not selected as the clustering method, set the value to NULL.
#' @return Return a list with 1 data frame, 1 interactive plot, and 1 static plot.
#' \enumerate{
#' \item umap_result: a data frame of UMAP data.
#' \item interactive_umap & static_umap: UMAP plot
#' }
#' @export
#' @examples
#' data("profiling_data")
#' processed_se <- data_process(profiling_data, exclude_missing=TRUE, exclude_missing_pct=70,
#'     replace_na_method='min', replace_na_method_ref=0.5, normalization='Percentage', transform='log10')
#' result_umap <- dr_umap(processed_se, n_neighbors=15, scaling=TRUE, umap_metric='euclidean',
#'     clustering='kmeans', cluster_num=2, kmedoids_metric=NULL,
#'     distfun=NULL, hclustfun=NULL, eps=NULL, minPts=NULL)
dr_umap <- function(
        processed_se, n_neighbors=15, scaling=c('none', FALSE, NULL, 'Z', 'scale', TRUE, 'maxabs', 'range', 'colrange'),
        umap_metric=c('euclidean', 'cosine', 'manhattan', 'hamming', 'categorical'),
        clustering=c('kmeans', 'kmedoids', 'hclustering', 'dbscan', 'group_info'),
        cluster_num=2, kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, eps=NULL, minPts=NULL){


    if(!is.numeric(n_neighbors) | isFALSE(.check_numeric_range(n_neighbors, 2, NULL))){
        stop('n_neighbors must be >= 2.')
    }
    valid_scaling <- c("none", FALSE, NULL, "Z", "scale", TRUE, "maxabs", "range", "colrange")
    if (isFALSE(scaling %in% valid_scaling)) {
        stop('scaling must be one of "none", FALSE, NULL, "Z", "scale", TRUE, "maxabs", "range", or "colrange".')
    }
    if (is.null(umap_metric) | isFALSE(umap_metric %in% c('euclidean', 'cosine', 'manhattan', 'hamming', 'correlation')) ) {
        stop("umap_metric must be one of 'euclidean', 'cosine', 'manhattan', 'hamming', or 'correlation'.")
    }
    .dr_check(clustering, cluster_num, kmedoids_metric, distfun, hclustfun, eps, minPts)

    # check SE
    .check_inputSE(processed_se, metadata_list=NULL)
    #if (is.null(names(S4Vectors::metadata(processed_se))) ) {
    if (all(names(S4Vectors::metadata(processed_se)) %in% c("processed_abund","transform")) &&
        length(names(S4Vectors::metadata(processed_se))) == 2) {
        abundance <- S4Vectors::metadata(processed_se)$processed_abund
        group_info <- NULL
    } else {
        de_data <- .deSig_data(de_se=processed_se)
        abundance <- de_data$abundance
        group_info <- de_data$group_info
    }
    umap_table <- .dim_process(abundance)
    color <- .dr_color()

    umap_result <- uwot::umap(
        umap_table, n_neighbors=n_neighbors, scale=scaling, metric=umap_metric)
    umap_data <- as.data.frame(umap_result) %>%
        dplyr::mutate(sample_name=colnames(abundance)[-1])
    colnames(umap_data)[seq_len(2)] <- c('UMAP-1', 'UMAP-2')
    ## grouping
    grouping <- .dim_grouping(
        umap_result, umap_table, group_info, clustering, cluster_num,
        kmedoids_metric, distfun, hclustfun, eps, minPts)
    cluster_group <- grouping$cluster_group
    cluster_group <- as.character(cluster_group)
    cluster_num <- grouping$cluster_num
    umap_data %<>% dplyr::mutate(group=cluster_group) %>%
        dplyr::select(sample_name, group, dplyr::everything())
    ## plotting
    umapPlot <- .umap_plotting(
        umap_result, umap_data, clustering, cluster_group, cluster_num, color)
    return(list(
        umap_result=umap_data, interactive_umap=umapPlot$in_umap,
        static_umap=umapPlot$umap_plot))
}

.umap_plotting <- function(
        umap_result, umap_data, clustering, cluster_group, cluster_num, color){
    if(clustering %in% c('dbscan')){
        umap_plot <-  factoextra::fviz_cluster(
            list(data=as.data.frame(umap_result), cluster=cluster_group),
            palette=color[seq_len(length(unique(cluster_group)))],
            geom="point", stand=FALSE, ellipse=FALSE,
            ggtheme=ggplot2::theme_bw(), show.clust.cent=FALSE, xlab='UMAP-1',
            ylab='UMAP-2', main="UMAP", legend.title='Groups')
        in_umap <- plotly::ggplotly(umap_plot)
        for (i in seq_len(length(in_umap$x$data))){
            if (!is.null(in_umap$x$data[[i]]$name)){
                in_umap$x$data[[i]]$name <- gsub("\\(", "", stringr::str_split(in_umap$x$data[[i]]$name, ",")[[1]][1])
            }
            if(i <= length(unique(cluster_group))){
                in_umap$x$data[[i]]$text <- paste(
                    "x :", round(in_umap$x$data[[i]]$x, 3), "\ny :",
                    round(in_umap$x$data[[i]]$y, 3), "\nGroups :",
                    in_umap$x$data[[i]]$name, "\nSample name :",
                    umap_data[which(umap_data$group == in_umap$x$data[[i]]$name), ]$sample_name)
            }
        }
    }else{
        umap_plot <- factoextra::fviz_cluster(
            list(data=as.data.frame(umap_result), cluster=cluster_group),
            palette=color[seq_len(cluster_num)], geom="point", stand=FALSE,
            ellipse=TRUE, ellipse.type='norm', ggtheme=ggplot2::theme_bw(),
            show.clust.cent=FALSE, xlab='UMAP-1', ylab='UMAP-2', main="UMAP",
            legend.title='Groups')
        in_umap <- plotly::ggplotly(umap_plot)
        for (i in seq_len(length(in_umap$x$data))){
            if (!is.null(in_umap$x$data[[i]]$name)){
                in_umap$x$data[[i]]$name <- gsub("\\(", "", stringr::str_split(in_umap$x$data[[i]]$name, ",")[[1]][1])
            }
            if(i <= cluster_num){
                in_umap$x$data[[i]]$text <- paste(
                    "x :", round(in_umap$x$data[[i]]$x, 3), "\ny :",
                    round(in_umap$x$data[[i]]$y, 3), "\nGroups :",
                    in_umap$x$data[[i]]$name, "\nSample name :",
                    umap_data[which( umap_data$group==in_umap$x$data[[i]]$name), ]$sample_name)
            } else if (i >= cluster_num+1 & i <= 2*cluster_num) {
                in_umap$x$data[[i]]$text <- paste("Groups :", in_umap$x$data[[i]]$name)
            }
        }
        for (i in seq_len(2*cluster_num)) {
            rev_n <- rev(seq_len(2*cluster_num))
            if(i == 1){rev_list <- list(in_umap$x$data[[rev_n[i]]])}
            else{rev_list<-c(rev_list, list(in_umap$x$data[[rev_n[i]]]))}
        }
        in_umap$x$data<- rev_list
    }
    return(list(in_umap=in_umap, umap_plot=umap_plot))
}


#' @title dr_plsda
#' @description Partial least squares Discriminant Analysis (PLS-DA) is a dimensionality reduction
#' method that transforms data from a high-dimensional space into a low-dimensional
#' space while retaining the original data's essential properties.
#' @param de_se The resulting SummarizedExperiment object from the differential
#' expression analysis function, such as \code{\link{deSp_twoGroup}}, \code{\link{deSp_multiGroup}},
#' \code{\link{deChar_twoGroup}}, and \code{\link{deChar_multiGroup}}.
#' @param ncomp Numeric. The number of components to include in
#' the model. Default is \code{2}.
#' @param scaling Logical. If scaling = TRUE, each block is
#' standardized to zero means and unit variances. Default is \code{TRUE}.
#' @param clustering Character. The method to be used for clustering. Allowed method
#' include "kmeans", "kmedoids", "hclustering", "dbscan", "group_info". Default is \code{"kmeans"}.
#' @param cluster_num Numeric. A positive integer specifying the number of clusters.
#' The number must be between 1 and 10. Default is \code{2}.
#' @param kmedoids_metric Character. The metric to be used for calculating
#' dissimilarities between observations when choosing \code{"kmedoids"} as clustering method.
#' Must be one of "euclidean" and "manhattan". If "kmedoids" is not selected as
#' the clustering method, set the value to NULL.
#' @param distfun Character. The distance measure to be used when choosing \code{"hclustering"}
#' as clustering method. Allow method include "pearson", "kendall", "spearman",
#' "euclidean", "manhattan", "maximum", "canberra", "binary", and "minkowski".
#' If "hclustering" is not selected as the clustering method, set the value to NULL.
#' @param hclustfun Character. The agglomeration method to be used when choosing
#' \code{"hclustering"} as clustering method. This should be (an unambiguous abbreviation of)
#' one of "ward.D", "ward.D2", "single", "complete", "average" (=UPGMA),
#' "mcquitty" (= WPGMA), "median" (= WPGMC), or "centroid" (= UPGMC).
#' If "hclustering" is not selected as the clustering method, set the value to NULL.
#' @param eps Numeric. The size of the epsilon neighborhood when choosing \code{"dbscan"} as clustering method.
#' If "dbscan" is not selected as the clustering method, set the value to NULL.
#' @param minPts number of minimum points in the eps region (for core points) when choosing dbscan as clustering method.
#' @return Return a list with 1 data frame, 1 interactive plot, and 1 static plot.
#' \enumerate{
#' \item plsda_result: A data frame of PLS-DA data.
#' \item table_plsda_loading: table for plotting PLS-DA loading plot.
#' \item interacitve_plsda & static_plsda: PLS-DA plot.
#' \item interactive_loadingPlot & static_loadingPlot: PLS-DA loading plot, display the variables that contribute to the definition of each component.
#' }
#' @export
#' @examples
#' data("de_data_twoGroup")
#' processed_se <- data_process(
#'     de_data_twoGroup, exclude_missing=TRUE, exclude_missing_pct=70,
#'     replace_na_method='min', replace_na_method_ref=0.5,
#'     normalization='Percentage', transform='log10')
#' deSp_se <- deSp_twoGroup(processed_se, ref_group='ctrl', test='t-test',
#'     significant='pval', p_cutoff=0.05, FC_cutoff=1, transform='log10')
#' result_plsda <- dr_plsda(deSp_se, ncomp=2, scaling=TRUE, clustering='group_info',
#'     cluster_num=2, kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, eps=NULL, minPts=NULL)
dr_plsda <- function(
    de_se, ncomp=2, scaling=TRUE,
    clustering=c('kmeans', 'kmedoids', 'hclustering', 'dbscan', 'group_info'),
    cluster_num=2, kmedoids_metric=NULL, distfun=NULL, hclustfun=NULL, eps=NULL, minPts=NULL){


    if(is.null(ncomp) | !is.numeric(ncomp) | isFALSE(.check_numeric_range(ncomp, 0, NULL))){
        stop('ncomp cannot be a negative value or NULL.')
    }
    if (!is.logical(scaling)) {
        stop("scaling must be a logical value.")
    }
    .dr_check(clustering, cluster_num, kmedoids_metric, distfun, hclustfun, eps, minPts)

    # must be de_se
    if (is.null(names(S4Vectors::metadata(de_se))) ){
        stop("Incorrect SummarizedExperiment structure. Please use the output from
             deSp_twoGroup, deSp_multiGroup, deChar_twoGroup, or deChar_multiGroup function.")
    }
    # SE
    de_data <- .deSig_data(de_se)
    abundance <- de_data$abundance
    group_info <- de_data$group_info

    num <- apply(abundance[-1], 1, FUN=function(x){length(unique(x))})
    abundance <- abundance[(num!=1),]
    abundance <- abundance[!is.infinite(rowSums(abundance[-1], na.rm=TRUE)),]
    group_info %<>% dplyr::filter(sample_name %in% colnames(abundance)[-1])
    Y <- group_info$group
    rownames(abundance) <- abundance$feature
    plsda_table <- abundance[c(colnames(SummarizedExperiment::rowData(de_se))[[1]], group_info$sample_name)] %>%
        dplyr::select(-1) %>% t()

    plsda.res <- mixOmics::plsda(plsda_table, Y, ncomp, scale=scaling)
    X.variate <- plsda.res$variates$X
    X.loading <- plsda.res$loadings$X
    ## grouping
    grouping <- .dim_grouping(
        X.variate, X.variate, group_info, clustering, cluster_num,
        kmedoids_metric, distfun, hclustfun, eps, minPts)
    cluster_group <- grouping$cluster_group
    cluster_num <- grouping$cluster_num
    cluster_group <- as.character(cluster_group)
    ## sample plot
    samplePlot <- .plsdaSample(X.variate, clustering, cluster_group, cluster_num)
    rown <- rownames(X.variate)
    X.variate <- X.variate %>% as.data.frame() %>%
        dplyr::mutate(sample_name=rown) %>%
        dplyr::mutate(group=cluster_group) %>%
        dplyr::select(sample_name, group, dplyr::everything())
    colnames(X.variate)[3:4] <- c('PLSDA1', 'PLSDA2')
    X.loading <- X.loading %>% as.data.frame()
    colnames(X.loading) <- c('PLSDA1', 'PLSDA2')
    ## loading plot
    variatePlot <- .plsdaVariate(plsda.res)
    return(list(
        plsda_result=X.variate, table_plsda_loading=X.loading,
        interacitve_plsda=samplePlot$in_sample,
        interactive_loadingPlot=variatePlot$in_variable,
        static_plsda=samplePlot$sample_plot,
        static_loadingPlot=variatePlot$variablePlot))
}

.plsdaSample <- function(
        X.variate, clustering, cluster_group, cluster_num){
    color <- .dr_color()
    if(clustering %in% c('dbscan')){
        sample.plot <-  factoextra::fviz_cluster(
            list(data=as.data.frame(X.variate), cluster=cluster_group),
            palette=color[seq_len(length(unique(cluster_group)))], geom="point",
            stand=FALSE, ellipse=FALSE, ggtheme=ggplot2::theme_bw(),
            show.clust.cent=FALSE, xlab='PLSDA-1', ylab='PLSDA-2', main="PLSDA",
            legend.title='Groups')
        in_sample <- plotly::ggplotly(sample.plot)
        for (i in seq_len(length(in_sample$x$data))){
            if (!is.null(in_sample$x$data[[i]]$name)){
                in_sample$x$data[[i]]$name <- .sampleName(in_sample, i)
            }
            if(i<=length(unique(cluster_group))){
                in_sample$x$data[[i]]$text <- .sampleGroup(in_sample, sample.plot, i)
            }
        }
    }else{
        sample.plot <- factoextra::fviz_cluster(
            list(data=as.data.frame(X.variate), cluster=cluster_group),
            palette=color[seq_len(cluster_num)], geom="point", stand=FALSE,
            ellipse=TRUE, ellipse.type='norm', ggtheme=ggplot2::theme_bw(),
            show.clust.cent=FALSE, xlab='PLSDA-1', ylab='PLSDA-2', main="PLSDA",
            legend.title='Groups')
        in_sample <- plotly::ggplotly(sample.plot)
        for (i in seq_len(length(in_sample$x$data))){
            if (!is.null(in_sample$x$data[[i]]$name)){
                in_sample$x$data[[i]]$name <- .sampleName(in_sample, i)
            }
            if (i <= cluster_num){
                in_sample$x$data[[i]]$text <- .sampleGroup(in_sample, sample.plot, i)
            } else if(i>=cluster_num+1 & i <= 2*cluster_num){
                in_sample$x$data[[i]]$text <- paste("Groups :", in_sample$x$data[[i]]$name)
            }
        }
        for (i in seq_len((2*cluster_num))) {
            rev_n <- rev(seq_len((2*cluster_num)))
            if (i == 1){
                rev_list <- list(in_sample$x$data[[rev_n[i]]])
            } else {
                rev_list<-c(rev_list, list(in_sample$x$data[[rev_n[i]]]))
            }
        }
        in_sample$x$data <- rev_list
    }
    return(list(in_sample=in_sample, sample_plot=sample.plot))
}

.sampleGroup <- function(in_sample, sample.plot, i){
    data <- paste(
        "x :", round(in_sample$x$data[[i]]$x, 3), "\ny :",
        round(in_sample$x$data[[i]]$y, 3), "\nGroups :",
        in_sample$x$data[[i]]$name, "\nSample name :",
        sample.plot$data[which(sample.plot$data$cluster==in_sample$x$data[[i]]$name), ]$name)
    return(data)
}

.sampleName <- function(in_sample, i){
    data <- gsub("\\(", "", stringr::str_split(in_sample$x$data[[i]]$name, ",")[[1]][1])
    return(data)
}

.plsdaVariate <- function(plsda.res){
    variable.tab <- mixOmics::plotVar(plsda.res, comp=seq_len(2), var.names=TRUE, plot=FALSE)
    circle_data_1 <- .creat_circle_data(1)
    circle_data_2 <- .creat_circle_data(0.5)
    in_variable <- plotly::plot_ly(x=~circle.x, y=~circle.y, hoverinfo="none") %>%
        plotly::add_trace(
            data=circle_data_1, type="scatter", mode="lines", hoverinfo="none",
            showlegend=FALSE, line=list(color='black', width=2)) %>%
        plotly::add_trace(
            data=circle_data_2, type="scatter", mode="lines", hoverinfo="none",
            showlegend=FALSE, line=list(color='black', width=2)) %>%
        plotly::add_trace(
            data=variable.tab, x=~x, y=~y, type="scatter", mode="markers",
            hoverinfo="text", showlegend=FALSE,
            marker=list(color="red", size=5), text=~paste(
                "x :", round(x, 3), "\ny :", round(y, 3), "\nfeature :", variable.tab$names)) %>%
        plotly::layout(
            xaxis=list(title="PLSDA-1"), yaxis=list(title="PLSDA-2"),
            title='Variables - PLSDA')
    circles <- data.frame(
        x0 = rep(0, 2), y0 = rep(0, 2), r = c(0.5, 1),
        stringsAsFactors = FALSE)
    variablePlot <- ggplot2::ggplot() +
        ggforce::geom_circle(data=circles, ggplot2::aes(x0=x0, y0=y0, r=r), show.legend = FALSE) +
        ggplot2::geom_text(
            data=variable.tab, ggplot2::aes(x=x, y=y, label=names),
            colour='#8B0000', check_overlap=FALSE, size=4, show.legend=FALSE) +
        ggplot2::theme_bw() +
        ggplot2::labs(x='PLSDA-1', y='PLSDA-2', title='Variables - PLSDA') +
        ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5))
    return(list(in_variable=in_variable, variablePlot=variablePlot))
}

.creat_circle_data <- function(r, x=0, y=0){
    circle.x <- seq(x-r, x+r, length.out =150)
    circle.y <- c(sqrt(r^2-circle.x^2), -sqrt(r^2-circle.x^2))
    circle.x <- c(circle.x,seq(x+r, x-r, length.out =150))
    circle <- data.frame(circle.x, circle.y)
}
